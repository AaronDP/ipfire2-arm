#!/bin/bash
#

eval $(/usr/local/bin/readhash /var/ipfire/ppp/settings)

# MAXRETRIES is now a count before red clear and if reconnection fail, eventually switching to a backup profil
MAXCONFIGURE=160
if [ ! $HOLDOFF ]; then
	HOLDOFF=30
fi

# Debugging. Comment it out to stop logging
DEBUG="yes"
msg() {
	if [ "z$DEBUG" != "z" ] ; then
		/usr/bin/logger -t red "Connectioncheck: $*"
	fi
	/bin/echo "$*"
}

if [ -s "/var/ipfire/red/keepconnected" ]; then
	ATTEMPTS=$(/bin/cat /var/ipfire/red/keepconnected)
else
	echo "0" > /var/ipfire/red/keepconnected
fi

case "$1" in
  start)
	# waiting pppd start or sync timout set at 90 s when available in driver
	# So just wait 5 s after 'red start' end where pppd should have been started
	TIMETOSTART=0
	while ( ! /bin/ps ax | /bin/grep -q [p]ppd ); do
		if [ ! -e "/var/ipfire/red/keepconnected" ]; then
			# user pressed disconnect in gui
			exit 0
		fi
		RCREDSTART=`/bin/ps ax | /bin/grep 'red start'`
		if [ "$TIMETOSTART" -eq 1 ]; then
			msg "fail before pppd start : no sync, trying again"
			/etc/rc.d/init.d/red stop
			/etc/rc.d/init.d/red clear
			/etc/rc.d/init.d/red start
			exit
		fi
		# give 5 s more at pppd to be visible  with ps ax after 'rc.red start' end
		if [ "$RCREDSTART" = '' ]; then
			TIMETOSTART=1
		fi
		/bin/sleep 5
	done

	#watching if an IP is received in $MAXCONFIGURE time to avoid some pppoa waiting forever even after LCP timeout
	COUNT=0
	while [ "$COUNT" -le "$MAXCONFIGURE" ]; do
		if [ ! -e "/var/ipfire/red/keepconnected" ]; then
			# user pressed disconnect in gui
			exit 0
		fi
		if [ -e "/var/ipfire/red/active" ]; then
			# connected in time so exit
			echo "0" > /var/ipfire/red/keepconnected
			exit 0
		fi
		if [ -e "/var/ipfire/red/dial-on-demand" ]; then
			# Don't count time when dial-on-demand is not really connected
			if ( ! /sbin/ifconfig | /bin/grep -q addr:10.64.64.64 ); then
				(( COUNT += 5 ))
			fi
		else
			(( COUNT += 5 ))
		fi
		if ( ! /bin/ps ax | /bin/grep -q [p]ppd ); then
			#pppd exit, so don't need to wait MAXCONFIGURE
			break
		fi
		/bin/sleep 5
	done
	msg "RED fail to connect"
	RCREDSTART=`/bin/ps ax | /bin/grep 'red start' | /usr/bin/cut -f1 -d ' '`
	if [ "$RCREDSTART" != '' ]; then
		/bin/kill "$RCREDSTART"
	fi
	# this attempt to connect fail, so retry

	#Don't erase keepconnected because it is used to watch user actions
	/bin/touch /var/ipfire/red/redial
	/etc/rc.d/init.d/red stop
	while ( /bin/ps ax | /bin/grep -q [p]ppd ); do
		msg "waiting pppd exit"
		/bin/sleep 2
	done
	/bin/sleep $HOLDOFF
	if [ ! -e "/var/ipfire/red/keepconnected" ]; then
		# user pressed disconnect in gui
		exit 0
	fi
	(( ATTEMPTS += 1 ))
	msg "Restarting $ATTEMPTS/$MAXRETRIES"
	if [ "$ATTEMPTS" -ge "$MAXRETRIES" ]; then
		echo "0" > /var/ipfire/red/keepconnected
		msg "Clearing RED interface"
		/etc/rc.d/init.d/red clear
		if [ "$BACKUPPROFILE" != '' ]; then
			/bin/rm -f /var/ipfire/ppp/settings
			/bin/cp "/var/ipfire/ppp/settings-$BACKUPPROFILE" /var/ipfire/ppp/settings
		fi
	else
		echo $ATTEMPTS > /var/ipfire/red/keepconnected
	fi
	/etc/rc.d/init.d/red start
	;;
  reconnect)
	while ( /bin/ps ax | /bin/grep -q [p]ppd ); do
		/bin/sleep 2
	done
	msg "will connect again"
	/etc/rc.d/init.d/red start
	;;
  *)
	/bin/echo "Usage: $0 {start|reconnect}"
	exit 1
	;;
esac
