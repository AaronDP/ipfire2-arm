#!/bin/sh
########################################################################
# Begin
#
# Description : RED Device Script
#
# Authors     : Michael Tremer - mitch@ipfire.org
#               Maniacikarus - maniacikarus@ipfire.org
# Inspired by : Nathan Coulson - nathan@linuxfromscratch.org
#               Kevin P. Fleming - kpfleming@linuxfromscratch.org
#
# Version     : 01.00
#
# Notes       : 
#
########################################################################

. /etc/sysconfig/rc 
. ${rc_functions}
eval $(/usr/local/bin/readhash /var/ipfire/ethernet/settings)

TYPE="${RED_TYPE}"
DEVICE="${RED_DEV}"

if [ "$TYPE" == "STATIC" ]; then
	ADDRESS="${RED_ADDRESS}"
	BROADCAST="${RED_BROADCAST}"
	NETADDRESS="${RED_NETADDRESS}"
	NETMASK="${RED_NETMASK}"
	GATEWAY="${DEFAULT_GATEWAY}"
	# DNS1
	# DNS2

	if [ -z "${BROADCAST}" ]; then
		boot_mesg "BROADCAST variable missing from input, cannot continue." ${FAILURE}
		echo_failure
		exit 1
	fi
	if [ -n "${ADDRESS}" -a -n "${NETMASK}" ]; then
		PREFIX=`whatmask ${NETMASK} | grep -e ^CIDR | awk -F': ' '{ print $2 }' | cut -c 2-`
		args="${args} ${ADDRESS}/${PREFIX} broadcast ${BROADCAST}"
	else
		boot_mesg "ADDRESS and/or NETMASK variable missing from input, cannot continue." ${FAILURE}
		echo_failure
		exit 1
	fi
	
elif [ "${TYPE}" == "DHCP" ]; then

	PIDFILE="/var/run/dhcpcd-${DEVICE}.pid"
	LEASEINFO="/var/ipfire/dhcpc/dhcpcd-${DEVICE}.info"
	DHCP_START="-N -R -L /var/ipfire/dhcpc -c /var/ipfire/dhcpc/dhcpcd.exe "
	DHCP_STOP="-k -c /var/ipfire/dhcpc/dhcpcd.exe "

fi

case "${1}" in
	start)
		boot_mesg "Bringing up the ${DEVICE} interface..."
		boot_mesg_flush
		
		# Check if an interface is there...
		if ip link show ${DEVICE} > /dev/null 2>&1; then
			link_status=`ip link show ${DEVICE} 2> /dev/null`
			if [ -n "${link_status}" ]; then
				if ! echo "${link_status}" | grep -q UP; then
					ip link set ${DEVICE} up
				fi
			fi
		else
			boot_mesg "Interface ${DEVICE} doesn't exist." ${FAILURE}
			echo_failure
			exit 1
		fi
		
		if [ "${TYPE}" == "STATIC" ]; then
			boot_mesg "Adding IPv4 address ${ADDRESS} to the ${DEVICE} interface..."
			ip addr add ${args} dev ${DEVICE}
			evaluate_retval
			echo -n "${DEVICE}" > /var/ipfire/red/iface
			echo -n "${ADDRESS}"  > /var/ipfire/red/local-ipaddress
			echo -n "${GATEWAY}" > /var/ipfire/red/remote-ipaddress
			echo -n "${DNS1}" > /var/ipfire/red/dns1
			echo -n "${DNS2}" > /var/ipfire/red/dns2
			touch /var/ipfire/red/active
			
			boot_mesg "Setting up default gateway ${GATEWAY}..."
			ip route add default via ${GATEWAY} dev ${DEVICE}
			evaluate_retval
			
			run_subdir ${rc_base}/init.d/networking/red.up/
			
		elif [ "${TYPE}" == "DHCP" ]; then
			boot_mesg -n "Starting dhcpcd on the ${DEVICE} interface..."		
			echo -n "${DEVICE}" > /var/ipfire/red/iface

			# Test to see if there is a stale pid file
			if [ -f "$PIDFILE" ]; then
				ps `cat "$PIDFILE"` | grep dhcpcd > /dev/null
				if [ $? != 0 ]; then
					rm -f /var/run/dhcpcd-${DEVICE}.pid > /dev/null
				else
					boot_mesg "dhcpcd already running!" ${WARNING}
					echo_warning
					exit 2
				fi
			fi
			
			iptables -A REDINPUT -p tcp --source-port 67 --destination-port 68 -i ${DEVICE} -j ACCEPT
			iptables -A REDINPUT -p udp --source-port 67 --destination-port 68 -i ${DEVICE} -j ACCEPT
			
			if [ -n "${DHCP_HOSTNAME}" ]; then
				DHCP_START+="-h ${DHCP_HOSTNAME} "
	  	fi
	  	
	  	/sbin/dhcpcd ${DEVICE} ${DHCP_START} >/dev/null 2>&1
	  	RET="$?"
	  	
	  	if [ "$RET" = "0" ]; then
				. /var/ipfire/dhcpc/dhcpcd-${DEVICE}.info
				echo ""
				echo_ok
				boot_mesg "           DHCP Assigned Settings for ${DEVICE}:"
				boot_mesg_flush
				boot_mesg "           IP Address:      $IPADDR"
				boot_mesg_flush
				if [ -n "${DHCP_HOSTNAME}" ]; then
					boot_mesg "           Hostname:        $DHCP_HOSTNAME"
					boot_mesg_flush
				fi
				boot_mesg "           Subnet Mask:     $NETMASK"
				boot_mesg_flush
				boot_mesg "           Default Gateway: $GATEWAY"
				boot_mesg_flush
				boot_mesg "           DNS Server:      $DNS"
				boot_mesg_flush
				
				echo -n `/etc/rc.d/helper/getdnsfromdhcpc.pl 1` > /var/ipfire/red/dns1
				echo -n `/etc/rc.d/helper/getdnsfromdhcpc.pl 2` > /var/ipfire/red/dns2

				. /var/ipfire/dhcpc/dhcpcd-${DEVICE}.info
				echo "$IPADDR"  > /var/ipfire/red/local-ipaddress
				echo "$GATEWAY" > /var/ipfire/red/remote-ipaddress
			else
				echo ""
				$(exit "$RET")
				evaluate_retval
			fi
		
		elif [ "$TYPE" == "PPPOE" ]; then
			
			if ( ps ax | grep -q [p]ppd ); then 
			    echo Error! A pppd is still running. Stop it first.
			    echo
			    exit 1;
			fi
			eval $(/usr/local/bin/readhash /var/ipfire/ppp/settings)
			
			[ -c "/dev/ppp" ] || mknod /dev/ppp c 108 0
			
			PPP_NIC=${DEVICE}
			
			if [ "$TYPE" == "pppoeatm" ]; then
				PPP_NIC=nas0		
				boot_mesg "Create ATM-Bridge as $PPP_NIC ..."
				br2684ctl -c0 -e${ENCAP} -a0.${VPI}.${VCI} >/dev/null 2>&1 &
				sleep 1
				ifconfig $PPP_NIC up
				TYPE="pppoe"
			fi
			if [ "$TYPE" == "pppoe" ]; then			
				boot_mesg "Bringing up the PPPoE interface on $PPP_NIC ..."
				ip addr add 1.1.1.1/24 broadcast 1.1.1.255 dev $PPP_NIC
			else
				boot_mesg "Bringing up the PPP via ${TYPE} on ${COMPORT}..."
			fi
			###                      ###
			### Configuring the pppd ###
			###                      ###
			
			### Plugin Options
			#			
			[ "${METHOD}" == "PPPOE_PLUGIN" ] && \
				PLUGOPTS="plugin /usr/lib/pppd/2.4.4/rp-pppoe.so"

				# PLUGOPTS="plugin /usr/lib/pppd/2.4.4/rp-pppoe.so nic-$PPP_NIC"

			### Synchronous Mode
			#
			#PPPOE_SYNC=-s
			#PPPD_SYNC=sync
	
			### Access Concentrator Name
			#
			if [ -n "${CONCENTRATORNAME}" ]; then
				ACNAME="-C ${CONCENTRATORNAME}"
			fi

			### Service Name
			#
			if [ -n "${SERVICENAME}" ]; then
				if [ "${METHOD}" == "PPPOE_PLUGIN" ]; then
					PLUGOPTS+=" rp_pppoe_service ${SERVICENAME}"
				else
					SERVICENAME="-S ${SERVICENAME}"
				fi
			fi

			### Authentication Types
			#
			if [ "${AUTH}" == "pap" ]; then
				AUTH="-chap"
			elif [ "${AUTH}" == "chap" ]; then
				AUTH="-pap"
			else
				AUTH=""
			fi

			### DNS Config
			#
			if [ "${DNS}" == "Automatic" ]; then
				DNS="usepeerdns"
			else
				DNS=""
				echo nameserver=$DNS1 > /etc/ppp/resolv.conf
				echo nameserver=$DNS2 >> /etc/ppp/resolv.conf
				
			fi

			### Dial On Demand		
			#
			if [ "${RECONNECTION}" != "persistent" ]; then
				if [ "${TIMEOUT}" != "0" ] && [ "${TIMEOUT}" != "" ]; then
					SECONDS=$[${TIMEOUT} * 60]
				else
					SECONDS=300
				fi
				if [ "${RECONNECTION}" == "dialondemand" ]; then
					touch /var/ipfire/red/dial-on-demand
					DEMAND="demand persist idle ${SECONDS} 10.112.112.112:10.112.112.113"
					DEMAND+=" ipcp-accept-remote ipcp-accept-local noipdefault ktune"
				fi
			fi
			
			### When using pppoe-plugin the device has to be the last option
			#
			[ "${METHOD}" == "PPPOE_PLUGIN" ] && PLUGOPTS+=" $PPP_NIC"
			
			if [ "$TYPE" == "modem" ]; then
				PLUGOPTS=" /dev/${COMPORT} ${DTERATE} connect /etc/ppp/dialer lock modem crtscts"
			elif [ "$TYPE" == "serial" ]; then
				PLUGOPTS=" /dev/${COMPORT} ${DTERATE} connect /bin/true lock modem crtscts"
			fi
		
			### Standard PPP options we always use
			#
			PPP_STD_OPTIONS="$PLUGOPTS $DNS defaultroute noipdefault noauth"
			PPP_STD_OPTIONS+=" default-asyncmap hide-password nodetach mtu ${MTU}"
			PPP_STD_OPTIONS+=" mru ${MTU} noaccomp nodeflate nopcomp novj novjccomp"
			PPP_STD_OPTIONS+=" nobsdcomp user ${USERNAME} lcp-echo-interval 20"
			PPP_STD_OPTIONS+=" lcp-echo-failure 3 ${AUTH}"
				
			### Debugging
			#
			if [ "${DEBUG}" == "on" ]; then
				DEBUG="debug"
			else
				DEBUG=""
			fi
			
			### PPPoE invocation
			#
			if [ "$TYPE" == "pppoe" ]; then
				PPPOE_CMD="/usr/sbin/pppoe -p /var/run/ppp-ipfire.pid.pppoe -I $PPP_NIC"
				PPPOE_CMD+=" -T 80 -U $PPPOE_SYNC $ACNAME $SERVICENAMEOPT"
			fi
			
			### Run everything
			#
			if [ "${METHOD}" == "PPPOE_PLUGIN" ]; then
				/usr/sbin/pppd $PPP_STD_OPTIONS $DEBUG $DEMAND >/dev/null 2>&1 &
				evaluate_retval
				# echo PLUGIN: /usr/sbin/pppd $PPP_STD_OPTIONS $DEBUG $DEMAND
			else
				/usr/sbin/pppd pty "$PPPOE_CMD" $PPP_STD_OPTIONS $DEBUG $DEMAND $PPPD_SYNC >/dev/null 2>&1 &
				evaluate_retval
				# echo PPP: /usr/sbin/pppd pty "$PPPOE_CMD" $PPP_STD_OPTIONS $DEBUG $DEMAND $PPPD_SYNC
			fi
			
			/etc/rc.d/init.d/connectd start

		fi
		;;

	stop)
		if [ "$TYPE" == "STATIC" ]; then
			boot_mesg "Removing IPv4 address ${ADDRESS} from the ${DEVICE} interface..."
			ip addr del ${args} dev ${DEVICE}
			evaluate_retval
			
			run_subdir ${rc_base}/init.d/networking/red.down/
			
		elif [ "$TYPE" == "DHCP" ]; then
			boot_mesg -n "Stopping dhcpcd on the ${DEVICE} interface..."
			if [ -e $LEASEINFO ]; then
				. $LEASEINFO
				if [ "$LEASETIME" = "4294967295" ]; then
					# do nothing, just echo ok
					echo ""
					echo_ok
				else
					if [ -n "$DHCP_STOP" ]; then
						/sbin/dhcpcd ${DEVICE} $DHCP_STOP &> /dev/null
						RET="$?"
						if [ "$RET" -eq 0 ]; then
							echo ""
							echo_ok
						elif [ "$RET" -eq 1 ]; then
							boot_mesg "dhcpcd not running!" ${WARNING}
							echo_warning
						else
							echo ""
							echo_failure
						fi
					else
						echo ""
						killproc dhcpcd
					fi
		    fi
			else
				boot_mesg -n "LEASEINFO Test failed! - " ${WARNING}
				boot_mesg "dhcpcd is not running!" ${WARNING}
				echo_warning
				exit 1
			fi
		
		elif [ "$TYPE" == "PPPOE" ]; then
			boot_mesg "Bringing down the PPP interface ..."
			rm -f /var/ipfire/red/keepconnected
			killall -w -s TERM /usr/sbin/pppd 2>/dev/null
			evaluate_retval
			killall -w -s TERM br2684ctl >/dev/null 2>&1
			ip addr del 1.1.1.1/24 broadcast 1.1.1.255 dev ${DEVICE}
			
		fi
		
		link_status=`ip link show $DEVICE 2> /dev/null`
		if [ -n "${link_status}" ]; then
			if echo "${link_status}" | grep -q UP; then
				boot_mesg "Bringing down the ${DEVICE} interface..."
				ip link set ${DEVICE} down
				evaluate_retval
			fi
		fi
		
		rm -f /var/ipfire/red/{active,device,dial-on-demand,dns1,dns2,local-ipaddress,remote-ipaddress,resolv.conf}
		;;
		
esac

# End
