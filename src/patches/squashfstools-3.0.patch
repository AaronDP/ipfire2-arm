diff -u squashfs3.0old/squashfs-tools/mksquashfs.c squashfs3.0/squashfs-tools/mksquashfs.c
--- squashfs3.0old/squashfs-tools/mksquashfs.c	2006-03-15 21:36:20.000000000 +0000
+++ squashfs3.0/squashfs-tools/mksquashfs.c	2006-04-17 10:58:49.000000000 +0100
@@ -72,7 +72,7 @@
 #define EXIT_MKSQUASHFS()	do {\
 					if(restore)\
 						restorefs();\
-					if(delete && destination_file && !block_device)\
+					if(deletesquash && destination_file && !block_device)\
 						unlink(destination_file);\
 					exit(1);\
 				} while(0)
@@ -81,7 +81,7 @@
 					EXIT_MKSQUASHFS();\
 				} while(0)
 
-int delete = FALSE;
+int deletesquash = FALSE;
 long long total_compressed = 0, total_uncompressed = 0;
 int fd;
 
@@ -251,6 +251,7 @@
 		squashfs_fragment_entry **fragment_table);
 int get_sorted_inode(squashfs_inode *inode, struct stat *buf);
 int read_sort_file(char *filename, int source, char *source_path[]);
+int dir_scan2(squashfs_inode *inode, struct dir_info *dir_info);
 void sort_files_and_write(struct dir_info *dir);
 struct file_info *duplicate(char *(get_next_file_block)(struct duplicate_buffer_handle *, unsigned int), struct duplicate_buffer_handle *file_start, long long bytes, unsigned int **block_list, long long *start, int blocks, struct fragment **fragment, char *frag_data, int frag_bytes);
 struct dir_info *dir_scan1(char *, int (_readdir)(char *, char *, struct dir_info *));
@@ -285,7 +286,7 @@
 }
 
 
-void sighandler()
+void sighandler(int signal)
 {
 	if(interrupted == 1)
 		restorefs();
@@ -297,7 +298,7 @@
 }
 
 
-void sighandler2()
+void sighandler2(int signal)
 {
 	EXIT_MKSQUASHFS();
 }
@@ -693,7 +694,7 @@
 
 void scan2_init_dir(struct directory *dir)
 {
-	if((dir->buff = malloc(SQUASHFS_METADATA_SIZE)) == NULL) {
+	if((dir->buff = (unsigned char *)malloc(SQUASHFS_METADATA_SIZE)) == NULL) {
 		BAD_ERROR("Out of memory allocating directory buffer\n");
 	}
 
@@ -720,7 +721,7 @@
 	}
 
 	if(dir->p + sizeof(squashfs_dir_entry) + size + sizeof(squashfs_dir_header) >= dir->buff + dir->size) {
-		if((buff = realloc(dir->buff, dir->size += SQUASHFS_METADATA_SIZE)) == NULL)  {
+		if((buff = (unsigned char *)realloc(dir->buff, dir->size += SQUASHFS_METADATA_SIZE)) == NULL)  {
 			BAD_ERROR("Out of memory reallocating directory buffer\n");
 		}
 
@@ -737,7 +738,7 @@
 
 			if((dir->p + sizeof(squashfs_dir_entry) + size - dir->index_count_p) > SQUASHFS_METADATA_SIZE) {
 				if(dir->i_count % I_COUNT_SIZE == 0)
-					if((dir->index = realloc(dir->index, (dir->i_count + I_COUNT_SIZE) * sizeof(struct cached_dir_index))) == NULL)
+					if((dir->index = (struct cached_dir_index *)realloc(dir->index, (dir->i_count + I_COUNT_SIZE) * sizeof(struct cached_dir_index))) == NULL)
 						BAD_ERROR("Out of memory in directory index table reallocation!\n");
 				dir->index[dir->i_count].index.index = dir->p - dir->buff;
 				dir->index[dir->i_count].index.size = size - 1;
@@ -1175,7 +1176,7 @@
 	int blocks = (read_size + block_size - 1) >> block_log, allocated_blocks = blocks;
 	unsigned int *block_list, *block_listp;
 
-	if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL)
+	if((block_list = (unsigned int *)malloc(blocks * sizeof(unsigned int))) == NULL)
 		BAD_ERROR("Out of memory allocating block_list\n");
 	block_listp = block_list;
 
@@ -1329,7 +1330,7 @@
 		inode = inode->next;
 	}
 
-	if((inode = malloc(sizeof(struct inode_info))) == NULL)
+	if((inode = (struct inode_info *)malloc(sizeof(struct inode_info))) == NULL)
 		BAD_ERROR("Out of memory in inode hash table entry allocation\n");
 
 	memcpy(&inode->buf, buf, sizeof(struct stat));
@@ -1350,10 +1351,10 @@
 inline void add_dir_entry(char *name, char *pathname, struct dir_info *sub_dir, struct inode_info *inode_info, void *data, struct dir_info *dir)
 {
 	if((dir->count % DIR_ENTRIES) == 0)
-		if((dir->list = realloc(dir->list, (dir->count + DIR_ENTRIES) * sizeof(struct dir_ent *))) == NULL)
+		if((dir->list = (struct dir_ent **)realloc(dir->list, (dir->count + DIR_ENTRIES) * sizeof(struct dir_ent *))) == NULL)
 			BAD_ERROR("Out of memory in add_dir_entry\n");
 
-	if((dir->list[dir->count] = malloc(sizeof(struct dir_ent))) == NULL)
+	if((dir->list[dir->count] = (struct dir_ent *)malloc(sizeof(struct dir_ent))) == NULL)
 		BAD_ERROR("Out of memory in linux_opendir\n");
 
 	if(sub_dir)
@@ -1363,7 +1364,7 @@
 	dir->list[dir->count]->inode = inode_info;
 	dir->list[dir->count]->dir = sub_dir;
 	dir->list[dir->count]->our_dir = dir;
-	dir->list[dir->count++]->data = data;
+	dir->list[dir->count++]->data = (struct old_root_entry_info *)data;
 	dir->byte_count += strlen(name) + sizeof(squashfs_dir_entry);
 }
 
@@ -1392,7 +1393,7 @@
 	struct dirent *d_name;
 	struct dir_info *dir;
 
-	if((dir = malloc(sizeof(struct dir_info))) == NULL)
+	if((dir = (struct dir_info *)malloc(sizeof(struct dir_info))) == NULL)
 		return NULL;
 
 	if(pathname[0] != '\0' && (dir->linuxdir = opendir(pathname)) == NULL) {
@@ -1527,10 +1528,10 @@
 	if(dir_info == NULL)
 		return;
 
-	if((dir_ent = malloc(sizeof(struct dir_ent))) == NULL)
+	if((dir_ent = (struct dir_ent *)malloc(sizeof(struct dir_ent))) == NULL)
 		BAD_ERROR("Out of memory in dir_scan\n");
 
-	if((inode_info = malloc(sizeof(struct inode_info))) == NULL)
+	if((inode_info = (struct inode_info *)malloc(sizeof(struct inode_info))) == NULL)
 		BAD_ERROR("Out of memory in dir_scan\n");
 
 	dir_ent->name = dir_ent->pathname = strdup(pathname);
@@ -1929,7 +1930,7 @@
 			break;
 
 		else if(strcmp(argv[i], "-noappend") == 0)
-			delete = TRUE;
+			deletesquash = TRUE;
 
 		else if(strcmp(argv[i], "-keep-as-directory") == 0)
 			keep_as_directory = TRUE;
@@ -1996,7 +1997,7 @@
 				perror("Could not create destination file");
 				exit(1);
 			}
-			delete = TRUE;
+			deletesquash = TRUE;
 		} else {
 			perror("Could not stat destination file");
 			exit(1);
@@ -2011,7 +2012,7 @@
 			block_device = 1;
 
 		} else if(S_ISREG(buf.st_mode))	 {
-			if((fd = open(argv[source + 1], (delete ? O_TRUNC : 0) | O_RDWR)) == -1) {
+			if((fd = open(argv[source + 1], (deletesquash ? O_TRUNC : 0) | O_RDWR)) == -1) {
 				perror("Could not open regular file for writing as destination");
 				exit(1);
 			}
@@ -2023,7 +2024,7 @@
 
 	}
 
-	if(!delete) {
+	if(!deletesquash) {
 	        if(read_super(fd, &sBlk, &orig_be, argv[source + 1]) == 0) {
 			ERROR("Failed to read existing filesystem - will not overwrite - ABORTING!\n");
 			EXIT_MKSQUASHFS();
@@ -2068,7 +2069,7 @@
 		else if(strcmp(argv[i], "-b") == 0 || strcmp(argv[i], "-root-becomes") == 0 || strcmp(argv[i], "-ef") == 0)
 			i++;
 
-	if(delete) {
+	if(deletesquash) {
 		printf("Creating %s %d.%d filesystem on %s, block size %d.\n",
 				be ? "big endian" : "little endian", SQUASHFS_MAJOR, SQUASHFS_MINOR, argv[source + 1], block_size);
 		bytes = sizeof(squashfs_super_block);
@@ -2176,7 +2177,7 @@
 
 	block_offset = check_data ? 3 : 2;
 
-	if(delete && !keep_as_directory && source == 1 && S_ISDIR(source_buf.st_mode))
+	if(deletesquash && !keep_as_directory && source == 1 && S_ISDIR(source_buf.st_mode))
 		dir_scan(&inode, source_path[0], scan1_readdir);
 	else if(!keep_as_directory && source == 1 && S_ISDIR(source_buf.st_mode))
 		dir_scan(&inode, source_path[0], scan1_single_readdir);
diff -u squashfs3.0old/squashfs-tools/read_fs.c squashfs3.0/squashfs-tools/read_fs.c
--- squashfs3.0old/squashfs-tools/read_fs.c	2006-03-15 21:36:21.000000000 +0000
+++ squashfs3.0/squashfs-tools/read_fs.c	2006-04-17 11:01:56.000000000 +0100
@@ -61,14 +61,14 @@
 						fprintf(stderr, s, ## args); \
 					} while(0)
 
-int swap;
+int swapsquash;
 
 int read_block(int fd, long long start, long long *next, unsigned char *block, squashfs_super_block *sBlk)
 {
 	unsigned short c_byte;
 	int offset = 2;
 	
-	if(swap) {
+	if(swapsquash) {
 		read_bytes(fd, start, 2, (char *) block);
 		((unsigned char *) &c_byte)[1] = block[0];
 		((unsigned char *) &c_byte)[0] = block[1]; 
@@ -125,7 +125,7 @@
 			*root_inode_block = bytes;
 		}
 		if((size - bytes < SQUASHFS_METADATA_SIZE) &&
-				((*inode_table = realloc(*inode_table, size += SQUASHFS_METADATA_SIZE)) == NULL))
+				((*inode_table = (unsigned char *)realloc(*inode_table, size += SQUASHFS_METADATA_SIZE)) == NULL))
 			return FALSE;
 		TRACE("scan_inode_table: reading block 0x%llx\n", start);
 		if((byte = read_block(fd, start, &start, *inode_table + bytes, sBlk)) == 0) {
@@ -145,14 +145,14 @@
 	 */
 	*root_inode_size = bytes - (*root_inode_block + root_inode_offset);
 	bytes = *root_inode_block + root_inode_offset;
-	if(swap) {
+	if(swapsquash) {
 		squashfs_base_inode_header sinode;
 		memcpy(&sinode, *inode_table + bytes, sizeof(dir_inode->base));
 		SQUASHFS_SWAP_BASE_INODE_HEADER(&dir_inode->base, &sinode, sizeof(squashfs_base_inode_header));
 	} else
 		memcpy(&dir_inode->base, *inode_table + bytes, sizeof(dir_inode->base));
 	if(dir_inode->base.inode_type == SQUASHFS_DIR_TYPE) {
-		if(swap) {
+		if(swapsquash) {
 			squashfs_dir_inode_header sinode;
 			memcpy(&sinode, *inode_table + bytes, sizeof(dir_inode->dir));
 			SQUASHFS_SWAP_DIR_INODE_HEADER(&dir_inode->dir, &sinode);
@@ -160,7 +160,7 @@
 			memcpy(&dir_inode->dir, *inode_table + bytes, sizeof(dir_inode->dir));
 		directory_start_block = dir_inode->dir.start_block;
 	} else {
-		if(swap) {
+		if(swapsquash) {
 			squashfs_ldir_inode_header sinode;
 			memcpy(&sinode, *inode_table + bytes, sizeof(dir_inode->ldir));
 			SQUASHFS_SWAP_LDIR_INODE_HEADER(&dir_inode->ldir, &sinode);
@@ -170,7 +170,7 @@
 	}
 
 	for(cur_ptr = *inode_table; cur_ptr < *inode_table + bytes; files ++) {
-		if(swap) {
+		if(swapsquash) {
 			squashfs_reg_inode_header sinode;
 			memcpy(&sinode, cur_ptr, sizeof(inode));
 			SQUASHFS_SWAP_REG_INODE_HEADER(&inode, &sinode);
@@ -191,13 +191,13 @@
 
 				TRACE("scan_inode_table: regular file, file_size %lld, blocks %d\n", inode.file_size, blocks);
 
-				if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL) {
+				if((block_list = (unsigned int *)malloc(blocks * sizeof(unsigned int))) == NULL) {
 					ERROR("Out of memory in block list malloc\n");
 					goto failed;
 				}
 
 				cur_ptr += sizeof(inode);
-				if(swap) {
+				if(swapsquash) {
 					unsigned int sblock_list[blocks];
 					memcpy(sblock_list, cur_ptr, blocks * sizeof(unsigned int));
 					SQUASHFS_SWAP_INTS(block_list, sblock_list, blocks);
@@ -222,7 +222,7 @@
 				int i, start;
 				unsigned int *block_list;
 
-				if(swap) {
+				if(swapsquash) {
 					squashfs_lreg_inode_header sinodep;
 					memcpy(&sinodep, cur_ptr, sizeof(sinodep));
 					SQUASHFS_SWAP_LREG_INODE_HEADER(&inode, &sinodep);
@@ -238,12 +238,12 @@
 					sBlk->block_log;
 				start = inode.start_block;
 
-				if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL) {
+				if((block_list = (unsigned int *)malloc(blocks * sizeof(unsigned int))) == NULL) {
 					ERROR("Out of memory in block list malloc\n");
 					goto failed;
 				}
 
-				if(swap) {
+				if(swapsquash) {
 					unsigned int sblock_list[blocks];
 					memcpy(sblock_list, cur_ptr, blocks * sizeof(unsigned int));
 					SQUASHFS_SWAP_INTS(block_list, sblock_list, blocks);
@@ -263,7 +263,7 @@
 			case SQUASHFS_SYMLINK_TYPE: {
 				squashfs_symlink_inode_header inodep;
 	
-				if(swap) {
+				if(swapsquash) {
 					squashfs_symlink_inode_header sinodep;
 					memcpy(&sinodep, cur_ptr, sizeof(sinodep));
 					SQUASHFS_SWAP_SYMLINK_INODE_HEADER(&inodep, &sinodep);
@@ -276,7 +276,7 @@
 			case SQUASHFS_DIR_TYPE: {
 				squashfs_dir_inode_header dir_inode;
 
-				if(swap) {
+				if(swapsquash) {
 					squashfs_dir_inode_header sinode;
 					memcpy(&sinode, cur_ptr, sizeof(dir_inode));
 					SQUASHFS_SWAP_DIR_INODE_HEADER(&dir_inode, &sinode);
@@ -292,7 +292,7 @@
 				squashfs_ldir_inode_header dir_inode;
 				int i;
 
-				if(swap) {
+				if(swapsquash) {
 					squashfs_ldir_inode_header sinode;
 					memcpy(&sinode, cur_ptr, sizeof(dir_inode));
 					SQUASHFS_SWAP_LDIR_INODE_HEADER(&dir_inode, &sinode);
@@ -304,7 +304,7 @@
 				cur_ptr += sizeof(squashfs_ldir_inode_header);
 				for(i = 0; i < dir_inode.i_count; i++) {
 					squashfs_dir_index index;
-					if(swap) {
+					if(swapsquash) {
 						squashfs_dir_index sindex;
 						memcpy(&sindex, cur_ptr, sizeof(squashfs_dir_index));
 						SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
@@ -348,14 +348,14 @@
 	read_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block), (char *) sBlk);
 
 	/* Check it is a SQUASHFS superblock */
-	swap = 0;
+	swapsquash = 0;
 	if(sBlk->s_magic != SQUASHFS_MAGIC) {
 		if(sBlk->s_magic == SQUASHFS_MAGIC_SWAP) {
 			squashfs_super_block sblk;
 			ERROR("Reading a different endian SQUASHFS filesystem on %s - ignoring -le/-be options\n", source);
 			SQUASHFS_SWAP_SUPER_BLOCK(&sblk, sBlk);
 			memcpy(sBlk, &sblk, sizeof(squashfs_super_block));
-			swap = 1;
+			swapsquash = 1;
 		} else  {
 			ERROR("Can't find a SQUASHFS superblock on %s\n", source);
 			goto failed_mount;
@@ -373,9 +373,9 @@
 	}
 
 #if __BYTE_ORDER == __BIG_ENDIAN
-	*be = !swap;
+	*be = !swapsquash;
 #else
-	*be = swap;
+	*be = swapsquash;
 #endif
 
 	printf("Found a valid SQUASHFS superblock on %s.\n", source);
@@ -416,7 +416,7 @@
 	long long start = sBlk->directory_table_start + directory_start_block, last_start_block; 
 
 	size += offset;
-	if((directory_table = malloc((size + SQUASHFS_METADATA_SIZE * 2 - 1) & ~(SQUASHFS_METADATA_SIZE - 1))) == NULL)
+	if((directory_table = (unsigned char *)malloc((size + SQUASHFS_METADATA_SIZE * 2 - 1) & ~(SQUASHFS_METADATA_SIZE - 1))) == NULL)
 		return NULL;
 	while(bytes < size) {
 		TRACE("squashfs_readdir: reading block 0x%llx, bytes read so far %d\n", start, bytes);
@@ -433,7 +433,7 @@
 
 	bytes = offset;
  	while(bytes < size) {			
-		if(swap) {
+		if(swapsquash) {
 			squashfs_dir_header sdirh;
 			memcpy(&sdirh, directory_table + bytes, sizeof(sdirh));
 			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
@@ -445,7 +445,7 @@
 		bytes += sizeof(dirh);
 
 		while(dir_count--) {
-			if(swap) {
+			if(swapsquash) {
 				squashfs_dir_entry sdire;
 				memcpy(&sdire, directory_table + bytes, sizeof(sdire));
 				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
@@ -481,7 +481,7 @@
 		return 0;
 	}
 
-	if(swap) {
+	if(swapsquash) {
 		squashfs_fragment_index sfragment_table_index[indexes];
 
 		read_bytes(fd, sBlk->fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments), (char *) sfragment_table_index);
@@ -494,7 +494,7 @@
 		TRACE("Read fragment table block %d, from 0x%llx, length %d\n", i, fragment_table_index[i], length);
 	}
 
-	if(swap) {
+	if(swapsquash) {
 		squashfs_fragment_entry sfragment;
 		for(i = 0; i < sBlk->fragments; i++) {
 			SQUASHFS_SWAP_FRAGMENT_ENTRY((&sfragment), (&(*fragment_table)[i]));
@@ -584,7 +584,7 @@
 		}
 		memcpy(*directory_data_cache, directory_table, *inode_dir_offset + *inode_dir_file_size);
 
-		if(!swap)
+		if(!swapsquash)
 			read_bytes(fd, sBlk->uid_start, sBlk->no_uids * sizeof(squashfs_uid), (char *) uids);
 		else {
 			squashfs_uid uids_copy[sBlk->no_uids];
@@ -593,7 +593,7 @@
 			SQUASHFS_SWAP_DATA(uids, uids_copy, sBlk->no_uids, sizeof(squashfs_uid) * 8);
 		}
 
-		if(!swap)
+		if(!swapsquash)
 			read_bytes(fd, sBlk->guid_start, sBlk->no_guids * sizeof(squashfs_uid), (char *) guids);
 		else {
 			squashfs_uid guids_copy[sBlk->no_guids];
diff -u squashfs3.0old/squashfs-tools/sort.c squashfs3.0/squashfs-tools/sort.c
--- squashfs3.0old/squashfs-tools/sort.c	2006-03-15 21:36:21.000000000 +0000
+++ squashfs3.0/squashfs-tools/sort.c	2006-04-17 11:01:33.000000000 +0100
@@ -87,7 +87,7 @@
 	struct priority_entry *new_priority_entry;
 
 	priority += 32768;
-	if((new_priority_entry = malloc(sizeof(struct priority_entry))) == NULL) {
+	if((new_priority_entry = (struct priority_entry *)malloc(sizeof(struct priority_entry))) == NULL) {
 		ERROR("Out of memory allocating priority entry\n");
 		return FALSE;
 	}
@@ -117,7 +117,7 @@
 #define ADD_ENTRY(buf, priority) {\
 	int hash = buf.st_ino & 0xffff;\
 	struct sort_info *s;\
-	if((s = malloc(sizeof(struct sort_info))) == NULL) {\
+	if((s = (struct sort_info *)malloc(sizeof(struct sort_info))) == NULL) {\
 		ERROR("Out of memory allocating sort list entry\n");\
 		return FALSE;\
 	}\
