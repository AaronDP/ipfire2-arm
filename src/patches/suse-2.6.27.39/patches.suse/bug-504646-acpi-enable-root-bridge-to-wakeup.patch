From: Rafael J. Wysocki <rjw@suse.de>
Subject: ACPI / PM: Allow PCI root bridges to wake up the system
References: bnc#504646

Wake-on-LAN with PCI network adapters currently doesn't work if the
adapter is not directly supported by ACPI.  In particular, it doesn't
work with add-on PCI (non-PCIe) adapters.

This problem has recently been fixed in the mainline kernel by
propagating the wake-up enable setting from the device to its
upstream bridge and, if necessary, further up to the root bridge.
Then, if one of the bridges on the path from the device to the root
bridge (or the root bridge itself) is an ACPI wake-up device, a PME
from the adapter causes the bridge's GPE to generate a wake-up
event.  Unfortunately, porting this solution into the SLE11 code base
would break KABI, so for systems that are known to have this problem,
if PCI root bridge is declared in the ACPI tables as a wake-up
device, allow it to wake up the system by default (this usually is
functionally equivalent the upstream solution, but it may cause
regressions to appear on the systems where this is not the case, so
use a DMI-based white list of systems that require it).

This allows add-on PCI devices to work as wake-up devices on some
systems, where PME# asserted by an add-on device causes the root
bridge GPE to generate a wake-up event, without using
/proc/acpi/wakeup to change the root bridge wake-up setting.

Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---
 drivers/acpi/glue.c         |   15 +++++++++++++++
 drivers/acpi/pci_root.c     |    9 +++++++++
 drivers/acpi/sleep/main.c   |   14 ++++++++++++++
 drivers/acpi/sleep/proc.c   |   29 +----------------------------
 drivers/acpi/sleep/sleep.h  |    6 ++++++
 drivers/acpi/sleep/wakeup.c |   35 +++++++++++++++++++++++++++++++++++
 include/acpi/acpi_bus.h     |    1 +
 7 files changed, 81 insertions(+), 28 deletions(-)

Index: linux-2.6.27-SLE11_BRANCH/drivers/acpi/glue.c
===================================================================
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/acpi/glue.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/acpi/glue.c
@@ -12,6 +12,14 @@
 #include <linux/rwsem.h>
 #include <linux/acpi.h>
 
+#include "sleep/sleep.h"
+
+/*
+ * If set, enable the PCI root bridge to wake-up the system from sleep states
+ * by default.
+ */
+bool acpi_root_bridge_wakeup;
+
 #define ACPI_GLUE_DEBUG	0
 #if ACPI_GLUE_DEBUG
 #define DBG(x...) printk(PREFIX x)
@@ -207,6 +215,13 @@ static int acpi_bind_one(struct device *
 				"physical_node");
 		if (acpi_dev->wakeup.flags.valid) {
 			device_set_wakeup_capable(dev, true);
+			if (acpi_root_bridge_wakeup
+			    && acpi_dev_is_root_bridge(acpi_dev)) {
+				spin_lock(&acpi_device_lock);
+				acpi_dev->wakeup.state.enabled = true;
+				propagate_enable_wakeup(acpi_dev);
+				spin_unlock(&acpi_device_lock);
+			}
 			device_set_wakeup_enable(dev,
 						acpi_dev->wakeup.state.enabled);
 		}
Index: linux-2.6.27-SLE11_BRANCH/drivers/acpi/pci_root.c
===================================================================
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/acpi/pci_root.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/acpi/pci_root.c
@@ -135,6 +135,15 @@ acpi_handle acpi_get_pci_rootbridge_hand
 
 EXPORT_SYMBOL_GPL(acpi_get_pci_rootbridge_handle);
 
+/**
+ * acpi_dev_is_root_bridge - determine if an ACPI device is a PCI root bridge
+ * @device: ACPI device to check.
+ */
+bool acpi_dev_is_root_bridge(struct acpi_device *device)
+{
+	return !acpi_match_device_ids(device, root_device_ids);
+}
+
 static acpi_status
 get_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
 {
Index: linux-2.6.27-SLE11_BRANCH/include/acpi/acpi_bus.h
===================================================================
--- linux-2.6.27-SLE11_BRANCH.orig/include/acpi/acpi_bus.h
+++ linux-2.6.27-SLE11_BRANCH/include/acpi/acpi_bus.h
@@ -380,6 +380,7 @@ struct device *acpi_get_physical_pci_dev
 
 /* helper */
 acpi_handle acpi_get_child(acpi_handle, acpi_integer);
+bool acpi_dev_is_root_bridge(struct acpi_device *);
 acpi_handle acpi_get_pci_rootbridge_handle(unsigned int, unsigned int);
 #define DEVICE_ACPI_HANDLE(dev) ((acpi_handle)((dev)->archdata.acpi_handle))
 
Index: linux-2.6.27-SLE11_BRANCH/drivers/acpi/sleep/wakeup.c
===================================================================
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/acpi/sleep/wakeup.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/acpi/sleep/wakeup.c
@@ -142,6 +142,41 @@ void acpi_disable_wakeup_device(u8 sleep
 	spin_unlock(&acpi_device_lock);
 }
 
+void physical_device_enable_wakeup(struct acpi_device *adev)
+{
+	struct device *dev = acpi_get_physical_device(adev->handle);
+
+	if (dev && device_can_wakeup(dev))
+		device_set_wakeup_enable(dev, adev->wakeup.state.enabled);
+}
+
+void propagate_enable_wakeup(struct acpi_device *wakeup_dev)
+{
+	struct list_head *node, *next;
+
+	list_for_each_safe(node, next, &acpi_wakeup_device_list) {
+		struct acpi_device *dev =
+			container_of(node, struct acpi_device, wakeup_list);
+
+		if (!dev->wakeup.flags.valid)
+			continue;
+
+		if (dev == wakeup_dev)
+			continue;
+
+		if (dev->wakeup.gpe_number != wakeup_dev->wakeup.gpe_number
+		    || dev->wakeup.gpe_device != wakeup_dev->wakeup.gpe_device)
+			continue;
+
+		printk(KERN_WARNING "ACPI: '%s' and '%s' share a GPE, "
+			"unable to disable/enable one seperately\n",
+			dev->pnp.bus_id, wakeup_dev->pnp.bus_id);
+
+		dev->wakeup.state.enabled = wakeup_dev->wakeup.state.enabled;
+		physical_device_enable_wakeup(dev);
+	}
+}
+
 static int __init acpi_wakeup_device_init(void)
 {
 	struct list_head *node, *next;
Index: linux-2.6.27-SLE11_BRANCH/drivers/acpi/sleep/proc.c
===================================================================
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/acpi/sleep/proc.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/acpi/sleep/proc.c
@@ -377,14 +377,6 @@ acpi_system_wakeup_device_seq_show(struc
 	return 0;
 }
 
-static void physical_device_enable_wakeup(struct acpi_device *adev)
-{
-	struct device *dev = acpi_get_physical_device(adev->handle);
-
-	if (dev && device_can_wakeup(dev))
-		device_set_wakeup_enable(dev, adev->wakeup.state.enabled);
-}
-
 static ssize_t
 acpi_system_write_wakeup_device(struct file *file,
 				const char __user * buffer,
@@ -420,26 +412,7 @@ acpi_system_write_wakeup_device(struct f
 	}
 	if (found_dev) {
 		physical_device_enable_wakeup(found_dev);
-		list_for_each_safe(node, next, &acpi_wakeup_device_list) {
-			struct acpi_device *dev = container_of(node,
-							       struct
-							       acpi_device,
-							       wakeup_list);
-
-			if ((dev != found_dev) &&
-			    (dev->wakeup.gpe_number ==
-			     found_dev->wakeup.gpe_number)
-			    && (dev->wakeup.gpe_device ==
-				found_dev->wakeup.gpe_device)) {
-				printk(KERN_WARNING
-				       "ACPI: '%s' and '%s' have the same GPE, "
-				       "can't disable/enable one seperately\n",
-				       dev->pnp.bus_id, found_dev->pnp.bus_id);
-				dev->wakeup.state.enabled =
-				    found_dev->wakeup.state.enabled;
-				physical_device_enable_wakeup(dev);
-			}
-		}
+		propagate_enable_wakeup(found_dev);
 	}
 	spin_unlock(&acpi_device_lock);
 	return count;
Index: linux-2.6.27-SLE11_BRANCH/drivers/acpi/sleep/sleep.h
===================================================================
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/acpi/sleep/sleep.h
+++ linux-2.6.27-SLE11_BRANCH/drivers/acpi/sleep/sleep.h
@@ -5,3 +5,9 @@ extern int acpi_suspend (u32 state);
 extern void acpi_enable_wakeup_device_prep(u8 sleep_state);
 extern void acpi_enable_wakeup_device(u8 sleep_state);
 extern void acpi_disable_wakeup_device(u8 sleep_state);
+extern void physical_device_enable_wakeup(struct acpi_device *adev);
+extern void propagate_enable_wakeup(struct acpi_device *root_dev);
+
+extern spinlock_t acpi_device_lock;
+
+extern bool acpi_root_bridge_wakeup;
Index: linux-2.6.27-SLE11_BRANCH/drivers/acpi/sleep/main.c
===================================================================
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/acpi/sleep/main.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/acpi/sleep/main.c
@@ -320,6 +320,12 @@ static int __init init_set_sci_en_on_res
 	return 0;
 }
 
+static int __init init_allow_root_bridge_wakeup(const struct dmi_system_id *d)
+{
+	acpi_root_bridge_wakeup = true;
+	return 0;
+}
+
 static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	{
 	.callback = init_old_suspend_ordering,
@@ -361,6 +367,14 @@ static struct dmi_system_id __initdata a
 		DMI_MATCH(DMI_PRODUCT_NAME, "HP xw4600 Workstation"),
 		},
 	},
+	{
+	.callback = init_allow_root_bridge_wakeup,
+	.ident = "IBM 4852526",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "IBM CORPORATION"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "4852526"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */
