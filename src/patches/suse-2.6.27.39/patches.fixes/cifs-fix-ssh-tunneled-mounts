From: Suresh Jayaraman <sjayaraman@suse.de>
Subject: [PATCH] cifs: fix broken mounts when a SSH tunnel is used (try #4)
References: bnc#527754
Patch-mainline: in cifs-2.6.git (merge expected in 2.6.32-rcX)
    
    It seems there is a regression that got introduced while Jeff fixed
    all the mount/umount races. While attempting to find whether a tcp
    session is already existing, we were not checking whether the "port"
    used are the same. When a second mount is attempted with a different
    "port=" option, it is being ignored. Because of this the cifs mounts
    that uses a SSH tunnel appears to be broken.
    
    Steps to reproduce:
    
    1. create 2 shares
    # SSH Tunnel a SMB session
    2. ssh -f -L 6111:127.0.0.1:445 root@localhost "sleep 86400"
    3. ssh -f -L 6222:127.0.0.1:445 root@localhost "sleep 86400"
    4. tcpdump -i lo 6111 &
    5. mkdir -p /mnt/mnt1
    6. mkdir -p /mnt/mnt2
    7. mount.cifs //localhost/a /mnt/mnt1 -o username=guest,ip=127.0.0.1,port=6111
    #(shows tcpdump activity on port 6111)
    8. mount.cifs //localhost/b /mnt/mnt2 -o username=guest,ip=127.0.0.1,port=6222
    #(shows tcpdump activity only on port 6111 and not on 6222
    
    Fix by adding a check to compare the port _only_ if the user tries to
    override the tcp port with "port=" option, before deciding that an
    existing tcp session is found. Also, clean up a bit by replacing
    if-else if by a switch statment while at it as suggested by Jeff.
    
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Reviewed-by: Shirish Pargaonkar <shirishp@us.ibm.com>
Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
Signed-off-by: Steve French <sfrench@us.ibm.com>
---
 fs/cifs/connect.c |   44 ++++++++++++++++++++++++++++++++++----------
 1 file changed, 34 insertions(+), 10 deletions(-)

Index: linux-2.6.27-SLE11_BRANCH/fs/cifs/connect.c
===================================================================
--- linux-2.6.27-SLE11_BRANCH.orig/fs/cifs/connect.c
+++ linux-2.6.27-SLE11_BRANCH/fs/cifs/connect.c
@@ -35,6 +35,7 @@
 #include <linux/freezer.h>
 #include <asm/uaccess.h>
 #include <asm/processor.h>
+#include <net/ipv6.h>
 #include "cifspdu.h"
 #include "cifsglob.h"
 #include "cifsproto.h"
@@ -1349,7 +1350,7 @@ cifs_parse_mount_options(char *options,
 }
 
 static struct TCP_Server_Info *
-cifs_find_tcp_session(struct sockaddr_storage *addr)
+cifs_find_tcp_session(struct sockaddr_storage *addr, unsigned short int port)
 {
 	struct list_head *tmp;
 	struct TCP_Server_Info *server;
@@ -1369,14 +1370,37 @@ cifs_find_tcp_session(struct sockaddr_st
 		if (server->tcpStatus == CifsNew)
 			continue;
 
-		if (addr->ss_family == AF_INET &&
-		    (addr4->sin_addr.s_addr !=
-		     server->addr.sockAddr.sin_addr.s_addr))
-			continue;
-		else if (addr->ss_family == AF_INET6 &&
-			 memcmp(&server->addr.sockAddr6.sin6_addr,
-				&addr6->sin6_addr, sizeof(addr6->sin6_addr)))
-			continue;
+		switch (addr->ss_family) {
+		case AF_INET:
+			if (addr4->sin_addr.s_addr ==
+			    server->addr.sockAddr.sin_addr.s_addr) {
+				addr4->sin_port = htons(port);
+				/* user overrode default port? */
+				if (addr4->sin_port) {
+					if (addr4->sin_port !=
+					    server->addr.sockAddr.sin_port)
+						continue;
+				}
+				break;
+			} else
+				continue;
+
+		case AF_INET6:
+			if (ipv6_addr_equal(&addr6->sin6_addr,
+			    &server->addr.sockAddr6.sin6_addr) &&
+			    (addr6->sin6_scope_id ==
+			    server->addr.sockAddr6.sin6_scope_id)) {
+				addr6->sin6_port = htons(port);
+				/* user overrode default port? */
+				if (addr6->sin6_port) {
+					if (addr6->sin6_port !=
+					   server->addr.sockAddr6.sin6_port)
+						continue;
+				}
+				break;
+			} else
+				continue;
+		}
 
 		++server->srv_count;
 		write_unlock(&cifs_tcp_ses_lock);
@@ -2111,7 +2135,7 @@ cifs_mount(struct super_block *sb, struc
 		}
 	}
 
-	srvTcp = cifs_find_tcp_session(&addr);
+	srvTcp = cifs_find_tcp_session(&addr, volume_info.port);
 	if (!srvTcp) { /* create socket */
 		if (addr.ss_family == AF_INET6) {
 			cFYI(1, ("attempting ipv6 connect"));
