From: Jan Kara <jack@suse.cz>
Subject: reiserfs: Truncate blocks not used by a write
References: bnc#483375
Patch-mainline: 2.6.32

It can happen that write does not use all the blocks allocated in write_begin
either because of some filesystem error (like ENOSPC) or because page with
data to write has been removed from memory. We truncate these blocks so that
we don't have dangling blocks beyond i_size. 

Signed-off-by: Jan Kara <jack@suse.cz>

diff -rupX /home/jack/.kerndiffexclude linux-2.6.27-SLE11_BRANCH/fs/reiserfs/inode.c linux-2.6.27-SLE11_BRANCH-1-reiserfs_corruption/fs/reiserfs/inode.c
--- linux-2.6.27-SLE11_BRANCH/fs/reiserfs/inode.c	2009-06-02 17:14:29.000000000 +0200
+++ linux-2.6.27-SLE11_BRANCH-1-reiserfs_corruption/fs/reiserfs/inode.c	2009-06-24 14:39:44.000000000 +0200
@@ -2606,6 +2610,8 @@ static int reiserfs_write_begin(struct f
 	if (ret) {
 		unlock_page(page);
 		page_cache_release(page);
+		/* Truncate allocated blocks */
+		vmtruncate(inode, inode->i_size);
 	}
 	return ret;
 }
@@ -2698,8 +2705,7 @@ static int reiserfs_write_end(struct fil
 	 ** transaction tracking stuff when the size changes.  So, we have
 	 ** to do the i_size updates here.
 	 */
-	pos += copied;
-	if (pos > inode->i_size) {
+	if (pos + copied > inode->i_size) {
 		struct reiserfs_transaction_handle myth;
 		reiserfs_write_lock(inode->i_sb);
 		/* If the file have grown beyond the border where it
@@ -2717,7 +2723,7 @@ static int reiserfs_write_end(struct fil
 			goto journal_error;
 		}
 		reiserfs_update_inode_transaction(inode);
-		inode->i_size = pos;
+		inode->i_size = pos + copied;
 		/*
 		 * this will just nest into our transaction.  It's important
 		 * to use mark_inode_dirty so the inode gets pushed around on the
@@ -2744,6 +2750,10 @@ static int reiserfs_write_end(struct fil
       out:
 	unlock_page(page);
 	page_cache_release(page);
+
+	if (pos + len > inode->i_size)
+		vmtruncate(inode, inode->i_size);
+
 	return ret == 0 ? copied : ret;
 
       journal_error:
