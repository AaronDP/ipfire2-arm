From: NeilBrown <neilb@suse.de>
Subject: [PATCH] md: 'array_size' sysfs attribute
References: bnc#498358

Allow userspace to set the size of the array according to the following
semantics:

1/ size must be <= to the size stored in mddev->array_size
   a) If size is set before the array is running, do_md_run will fail
      if size is greater than the default size
   b) A reshape attempt that reduces the default size to less than the set
      array size should be blocked
2/ once userspace sets the size the kernel will not change it
3/ writing 'default' to this attribute returns control of the size to the
   kernel and reverts to the size reported by the personality

To avoid kabi break we store the user-specified size in ->queue->end_sector
which is otherwise unused by md devices.

(based on a patch which was)
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>
---
 drivers/md/linear.c |    3 +
 drivers/md/md.c     |   85 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 drivers/md/raid1.c  |   14 ++++----
 drivers/md/raid5.c  |    9 +++--
 4 files changed, 99 insertions(+), 12 deletions(-)

--- linux-2.6.27-SLE11_BRANCH.orig/drivers/md/linear.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/md/linear.c
@@ -295,7 +295,8 @@ static int linear_add(mddev_t *mddev, md
 	mddev->private = newconf;
 	mddev->raid_disks++;
 	mddev->array_sectors = newconf->array_sectors;
-	set_capacity(mddev->gendisk, mddev->array_sectors);
+	if (mddev->queue->end_sector == 0)
+		set_capacity(mddev->gendisk, mddev->array_sectors);
 	return 0;
 }
 
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/md/md.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/md/md.c
@@ -287,6 +287,7 @@ static mddev_t * mddev_find(dev_t unit)
 		kfree(new);
 		return NULL;
 	}
+	new->queue->end_sector = 0;
 	/* Can be unlocked because the queue is new: no concurrency */
 	queue_flag_set_unlocked(QUEUE_FLAG_CLUSTER, new->queue);
 
@@ -2136,6 +2137,25 @@ rdev_size_show(mdk_rdev_t *rdev, char *p
 	return sprintf(page, "%llu\n", (unsigned long long)rdev->size);
 }
 
+static int strict_blocks_to_sectors(const char *buf, sector_t *sectors)
+{
+	unsigned long long blocks;
+	sector_t new;
+
+	if (strict_strtoull(buf, 10, &blocks) < 0)
+		return -EINVAL;
+
+	if (blocks & 1ULL << (8 * sizeof(blocks) - 1))
+		return -EINVAL; /* sector conversion overflow */
+
+	new = blocks * 2;
+	if (new != blocks * 2)
+		return -EINVAL; /* unsigned long long to sector_t overflow */
+
+	*sectors = new;
+	return 0;
+}
+
 static int overlaps(sector_t s1, sector_t l1, sector_t s2, sector_t l2)
 {
 	/* check if two start/length pairs overlap */
@@ -3397,6 +3417,55 @@ static struct md_sysfs_entry md_reshape_
 __ATTR(reshape_position, S_IRUGO|S_IWUSR, reshape_position_show,
        reshape_position_store);
 
+static ssize_t
+array_size_show(mddev_t *mddev, char *page)
+{
+	if (mddev->queue->end_sector)
+		return sprintf(page, "%llu\n",
+			       (unsigned long long)mddev->queue->end_sector/2);
+	else
+		return sprintf(page, "default\n");
+}
+
+static ssize_t
+array_size_store(mddev_t *mddev, const char *buf, size_t len)
+{
+	sector_t sectors;
+
+	if (strncmp(buf, "default", 7) == 0) {
+		sectors = mddev->array_sectors;
+
+		mddev->queue->end_sector = 0;
+	} else {
+		if (strict_blocks_to_sectors(buf, &sectors) < 0)
+			return -EINVAL;
+		if (sectors < 2)
+			return -EINVAL;
+		if (mddev->pers && mddev->array_sectors < sectors)
+			return -E2BIG;
+
+		mddev->queue->end_sector = sectors;
+	}
+
+	set_capacity(mddev->gendisk, sectors);
+	if (mddev->pers) {
+		struct block_device *bdev = bdget_disk(mddev->gendisk, 0);
+
+		if (bdev) {
+			mutex_lock(&bdev->bd_inode->i_mutex);
+			i_size_write(bdev->bd_inode,
+				     (loff_t)sectors << 9);
+			mutex_unlock(&bdev->bd_inode->i_mutex);
+			bdput(bdev);
+		}
+	}
+
+	return len;
+}
+
+static struct md_sysfs_entry md_array_size =
+__ATTR(array_size, S_IRUGO|S_IWUSR, array_size_show,
+       array_size_store);
 
 static struct attribute *md_default_attrs[] = {
 	&md_level.attr,
@@ -3410,6 +3479,7 @@ static struct attribute *md_default_attr
 	&md_safe_delay.attr,
 	&md_array_state.attr,
 	&md_reshape_position.attr,
+	&md_array_size.attr,
 	NULL,
 };
 
@@ -3721,7 +3791,15 @@ static int do_md_run(mddev_t * mddev)
 	err = mddev->pers->run(mddev);
 	if (err)
 		printk(KERN_ERR "md: pers->run() failed ...\n");
-	else if (mddev->pers->sync_request) {
+	else if (mddev->queue->end_sector &&
+		 mddev->queue->end_sector > mddev->array_sectors) {
+		printk(KERN_ERR
+		       "md: invalid array_size %llu > default size %llu\n",
+		       (unsigned long long)mddev->queue->end_sector / 2,
+		       (unsigned long long)mddev->array_sectors / 2);
+		err = -EINVAL;
+		mddev->pers->stop(mddev);
+	} else if (mddev->pers->sync_request) {
 		err = bitmap_create(mddev);
 		if (err) {
 			printk(KERN_ERR "%s: failed to create bitmap (%d)\n",
@@ -3764,7 +3842,10 @@ static int do_md_run(mddev_t * mddev)
 	if (mddev->flags)
 		md_update_sb(mddev, 0);
 
-	set_capacity(disk, mddev->array_sectors);
+	if (mddev->queue->end_sector)
+		set_capacity(disk, mddev->queue->end_sector);
+	else
+		set_capacity(disk, mddev->array_sectors);
 
 	/* If we call blk_queue_make_request here, it will
 	 * re-initialise max_sectors etc which may have been
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/md/raid1.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/md/raid1.c
@@ -2108,12 +2108,14 @@ static int raid1_resize(mddev_t *mddev, 
 	 * worth it.
 	 */
 	mddev->array_sectors = sectors;
-	set_capacity(mddev->gendisk, mddev->array_sectors);
-	mddev->changed = 1;
-	if (mddev->array_sectors / 2 > mddev->size &&
-	    mddev->recovery_cp == MaxSector) {
-		mddev->recovery_cp = mddev->size << 1;
-		set_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
+	if (mddev->queue->end_sector == 0) {
+		set_capacity(mddev->gendisk, mddev->array_sectors);
+		mddev->changed = 1;
+		if (mddev->array_sectors / 2 > mddev->size &&
+		    mddev->recovery_cp == MaxSector) {
+			mddev->recovery_cp = mddev->size << 1;
+			set_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
+		}
 	}
 	mddev->size = mddev->array_sectors / 2;
 	mddev->resync_max_sectors = sectors;
--- linux-2.6.27-SLE11_BRANCH.orig/drivers/md/raid5.c
+++ linux-2.6.27-SLE11_BRANCH/drivers/md/raid5.c
@@ -4650,7 +4650,8 @@ static int raid5_resize(mddev_t *mddev, 
 	sectors &= ~((sector_t)mddev->chunk_size/512 - 1);
 	mddev->array_sectors = sectors * (mddev->raid_disks
 					  - conf->max_degraded);
-	set_capacity(mddev->gendisk, mddev->array_sectors);
+	if (mddev->queue->end_sector == 0)
+		set_capacity(mddev->gendisk, mddev->array_sectors);
 	mddev->changed = 1;
 	if (sectors/2  > mddev->size && mddev->recovery_cp == MaxSector) {
 		mddev->recovery_cp = mddev->size << 1;
@@ -4788,11 +4789,13 @@ static void end_reshape(raid5_conf_t *co
 	if (!test_bit(MD_RECOVERY_INTR, &conf->mddev->recovery)) {
 		conf->mddev->array_sectors = 2 * conf->mddev->size *
 			(conf->raid_disks - conf->max_degraded);
-		set_capacity(conf->mddev->gendisk, conf->mddev->array_sectors);
+		if (conf->mddev->queue->end_sector == 0)
+			set_capacity(conf->mddev->gendisk,
+				     conf->mddev->array_sectors);
 		conf->mddev->changed = 1;
 
 		bdev = bdget_disk(conf->mddev->gendisk, 0);
-		if (bdev) {
+		if (bdev && conf->mddev->queue->end_sector == 0) {
 			mutex_lock(&bdev->bd_inode->i_mutex);
 			i_size_write(bdev->bd_inode,
 				     (loff_t)conf->mddev->array_sectors << 9);
