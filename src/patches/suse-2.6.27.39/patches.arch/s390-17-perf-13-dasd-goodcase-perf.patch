From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: [PATCH] dasd: optimize cpu usage in goodcase
References: bnc#532063,LTC#55526

From: Stefan Haberland <stefan.haberland@de.ibm.com>

remove unnecessary dbf call, remove string operations for magic

Signed-off-by: Stefan Haberland <stefan.haberland@de.ibm.com>

Acked-by: John Jolly <jjolly@suse.de>

---
 drivers/s390/block/dasd.c       |   21 ++++++++-------------
 drivers/s390/block/dasd_alias.c |    3 +--
 drivers/s390/block/dasd_diag.c  |    3 +--
 drivers/s390/block/dasd_eckd.c  |   35 +++++++++++++++--------------------
 drivers/s390/block/dasd_eer.c   |    2 +-
 drivers/s390/block/dasd_fba.c   |    5 ++---
 drivers/s390/block/dasd_int.h   |   11 ++++++++---
 7 files changed, 36 insertions(+), 44 deletions(-)

Index: linux-sles11/drivers/s390/block/dasd.c
===================================================================
--- linux-sles11.orig/drivers/s390/block/dasd.c
+++ linux-sles11/drivers/s390/block/dasd.c
@@ -645,14 +645,14 @@ static void dasd_profile_end(struct dasd
  * memory and 2) dasd_smalloc_request uses the static ccw memory
  * that gets allocated for each device.
  */
-struct dasd_ccw_req *dasd_kmalloc_request(char *magic, int cplength,
+struct dasd_ccw_req *dasd_kmalloc_request(int magic, int cplength,
 					  int datasize,
 					  struct dasd_device *device)
 {
 	struct dasd_ccw_req *cqr;
 
 	/* Sanity checks */
-	BUG_ON( magic == NULL || datasize > PAGE_SIZE ||
+	BUG_ON(datasize > PAGE_SIZE ||
 	     (cplength*sizeof(struct ccw1)) > PAGE_SIZE);
 
 	cqr = kzalloc(sizeof(struct dasd_ccw_req), GFP_ATOMIC);
@@ -676,14 +676,13 @@ struct dasd_ccw_req *dasd_kmalloc_reques
 			return ERR_PTR(-ENOMEM);
 		}
 	}
-	strncpy((char *) &cqr->magic, magic, 4);
-	ASCEBC((char *) &cqr->magic, 4);
+	cqr->magic =  magic;
 	set_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);
 	dasd_get_device(device);
 	return cqr;
 }
 
-struct dasd_ccw_req *dasd_smalloc_request(char *magic, int cplength,
+struct dasd_ccw_req *dasd_smalloc_request(int magic, int cplength,
 					  int datasize,
 					  struct dasd_device *device)
 {
@@ -693,7 +692,7 @@ struct dasd_ccw_req *dasd_smalloc_reques
 	int size;
 
 	/* Sanity checks */
-	BUG_ON( magic == NULL || datasize > PAGE_SIZE ||
+	BUG_ON(datasize > PAGE_SIZE ||
 	     (cplength*sizeof(struct ccw1)) > PAGE_SIZE);
 
 	size = (sizeof(struct dasd_ccw_req) + 7L) & -8L;
@@ -720,8 +719,7 @@ struct dasd_ccw_req *dasd_smalloc_reques
 		cqr->data = data;
  		memset(cqr->data, 0, datasize);
 	}
-	strncpy((char *) &cqr->magic, magic, 4);
-	ASCEBC((char *) &cqr->magic, 4);
+	cqr->magic = magic;
 	set_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);
 	dasd_get_device(device);
 	return cqr;
@@ -865,9 +863,6 @@ int dasd_start_IO(struct dasd_ccw_req *c
 	switch (rc) {
 	case 0:
 		cqr->status = DASD_CQR_IN_IO;
-		DBF_DEV_EVENT(DBF_DEBUG, device,
-			      "start_IO: request %p started successful",
-			      cqr);
 		break;
 	case -EBUSY:
 		DBF_DEV_EVENT(DBF_ERR, device, "%s",
@@ -2393,7 +2388,7 @@ int dasd_generic_notify(struct ccw_devic
 static struct dasd_ccw_req *dasd_generic_build_rdc(struct dasd_device *device,
 						   void *rdc_buffer,
 						   int rdc_buffer_size,
-						   char *magic)
+						   int magic)
 {
 	struct dasd_ccw_req *cqr;
 	struct ccw1 *ccw;
@@ -2422,7 +2417,7 @@ static struct dasd_ccw_req *dasd_generic
 }
 
 
-int dasd_generic_read_dev_chars(struct dasd_device *device, char *magic,
+int dasd_generic_read_dev_chars(struct dasd_device *device, int magic,
 				void **rdc_buffer, int rdc_buffer_size)
 {
 	int ret;
Index: linux-sles11/drivers/s390/block/dasd_alias.c
===================================================================
--- linux-sles11.orig/drivers/s390/block/dasd_alias.c
+++ linux-sles11/drivers/s390/block/dasd_alias.c
@@ -377,8 +377,7 @@ static int read_unit_address_configurati
 	int rc;
 	unsigned long flags;
 
-	cqr = dasd_kmalloc_request("ECKD",
-				   1 /* PSF */	+ 1 /* RSSD */ ,
+	cqr = dasd_kmalloc_request(DASD_ECKD_MAGIC, 1 /* PSF */	+ 1 /* RSSD */,
 				   (sizeof(struct dasd_psf_prssd_data)),
 				   device);
 	if (IS_ERR(cqr))
Index: linux-sles11/drivers/s390/block/dasd_diag.c
===================================================================
--- linux-sles11.orig/drivers/s390/block/dasd_diag.c
+++ linux-sles11/drivers/s390/block/dasd_diag.c
@@ -521,8 +521,7 @@ static struct dasd_ccw_req *dasd_diag_bu
 	/* Build the request */
 	datasize = sizeof(struct dasd_diag_req) +
 		count*sizeof(struct dasd_diag_bio);
-	cqr = dasd_smalloc_request(dasd_diag_discipline.name, 0,
-				   datasize, memdev);
+	cqr = dasd_smalloc_request(DASD_DIAG_MAGIC, 0, datasize, memdev);
 	if (IS_ERR(cqr))
 		return cqr;
 
Index: linux-sles11/drivers/s390/block/dasd_eckd.c
===================================================================
--- linux-sles11.orig/drivers/s390/block/dasd_eckd.c
+++ linux-sles11/drivers/s390/block/dasd_eckd.c
@@ -582,7 +582,8 @@ static struct dasd_ccw_req *dasd_eckd_bu
 	struct dasd_ccw_req *cqr;
 	struct ccw1 *ccw;
 
-	cqr = dasd_smalloc_request("ECKD", 1 /* RCD */, ciw->count, device);
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 /* RCD */, ciw->count,
+				   device);
 
 	if (IS_ERR(cqr)) {
 		DEV_MESSAGE(KERN_WARNING, device, "%s",
@@ -784,8 +785,7 @@ static int dasd_eckd_read_features(struc
 	struct dasd_eckd_private *private;
 
 	private = (struct dasd_eckd_private *) device->private;
-	cqr = dasd_smalloc_request(dasd_eckd_discipline.name,
-				   1 /* PSF */	+ 1 /* RSSD */ ,
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 /* PSF */	+ 1 /* RSSD */,
 				   (sizeof(struct dasd_psf_prssd_data) +
 				    sizeof(struct dasd_rssd_features)),
 				   device);
@@ -846,7 +846,7 @@ static struct dasd_ccw_req *dasd_eckd_bu
 	struct dasd_psf_ssc_data *psf_ssc_data;
 	struct ccw1 *ccw;
 
-	cqr = dasd_smalloc_request("ECKD", 1 /* PSF */ ,
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 /* PSF */ ,
 				  sizeof(struct dasd_psf_ssc_data),
 				  device);
 
@@ -995,7 +995,8 @@ dasd_eckd_check_characteristics(struct d
 	/* Read Device Characteristics */
 	rdc_data = (void *) &(private->rdc_data);
 	memset(rdc_data, 0, sizeof(rdc_data));
-	rc = dasd_generic_read_dev_chars(device, "ECKD", &rdc_data, 64);
+	rc = dasd_generic_read_dev_chars(device, DASD_ECKD_MAGIC, &rdc_data,
+					 64);
 	if (rc) {
 		DEV_MESSAGE(KERN_WARNING, device,
 			    "Read device characteristics returned "
@@ -1055,8 +1056,7 @@ dasd_eckd_analysis_ccw(struct dasd_devic
 
 	cplength = 8;
 	datasize = sizeof(struct DE_eckd_data) + 2*sizeof(struct LO_eckd_data);
-	cqr = dasd_smalloc_request(dasd_eckd_discipline.name,
-				   cplength, datasize, device);
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize, device);
 	if (IS_ERR(cqr))
 		return cqr;
 	ccw = cqr->cpaddr;
@@ -1327,8 +1327,7 @@ dasd_eckd_format_device(struct dasd_devi
 		return ERR_PTR(-EINVAL);
 	}
 	/* Allocate the format ccw request. */
-	fcp = dasd_smalloc_request(dasd_eckd_discipline.name,
-				   cplength, datasize, device);
+	fcp = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize, device);
 	if (IS_ERR(fcp))
 		return fcp;
 
@@ -1607,8 +1606,8 @@ static struct dasd_ccw_req *dasd_eckd_bu
 		datasize += count*sizeof(struct LO_eckd_data);
 	}
 	/* Allocate the ccw request. */
-	cqr = dasd_smalloc_request(dasd_eckd_discipline.name,
-				   cplength, datasize, startdev);
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize,
+				   startdev);
 	if (IS_ERR(cqr))
 		return cqr;
 	ccw = cqr->cpaddr;
@@ -1865,8 +1864,7 @@ dasd_eckd_release(struct dasd_device *de
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	cqr = dasd_smalloc_request(dasd_eckd_discipline.name,
-				   1, 32, device);
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device);
 	if (IS_ERR(cqr)) {
 		DEV_MESSAGE(KERN_WARNING, device, "%s",
 			    "Could not allocate initialization request");
@@ -1906,8 +1904,7 @@ dasd_eckd_reserve(struct dasd_device *de
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	cqr = dasd_smalloc_request(dasd_eckd_discipline.name,
-				   1, 32, device);
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device);
 	if (IS_ERR(cqr)) {
 		DEV_MESSAGE(KERN_WARNING, device, "%s",
 			    "Could not allocate initialization request");
@@ -1946,8 +1943,7 @@ dasd_eckd_steal_lock(struct dasd_device 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	cqr = dasd_smalloc_request(dasd_eckd_discipline.name,
-				   1, 32, device);
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device);
 	if (IS_ERR(cqr)) {
 		DEV_MESSAGE(KERN_WARNING, device, "%s",
 			    "Could not allocate initialization request");
@@ -1984,8 +1980,7 @@ dasd_eckd_performance(struct dasd_device
 	struct ccw1 *ccw;
 	int rc;
 
-	cqr = dasd_smalloc_request(dasd_eckd_discipline.name,
-				   1 /* PSF */  + 1 /* RSSD */ ,
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 /* PSF */  + 1 /* RSSD */,
 				   (sizeof(struct dasd_psf_prssd_data) +
 				    sizeof(struct dasd_rssd_perf_stats_t)),
 				   device);
@@ -2131,7 +2126,7 @@ static int dasd_symm_io(struct dasd_devi
 	}
 
 	/* setup CCWs for PSF + RSSD */
-	cqr = dasd_smalloc_request("ECKD", 2 , 0, device);
+	cqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 2 , 0, device);
 	if (IS_ERR(cqr)) {
 		DEV_MESSAGE(KERN_WARNING, device, "%s",
 			"Could not allocate initialization request");
Index: linux-sles11/drivers/s390/block/dasd_eer.c
===================================================================
--- linux-sles11.orig/drivers/s390/block/dasd_eer.c
+++ linux-sles11/drivers/s390/block/dasd_eer.c
@@ -456,7 +456,7 @@ int dasd_eer_enable(struct dasd_device *
 	if (!device->discipline || strcmp(device->discipline->name, "ECKD"))
 		return -EPERM;	/* FIXME: -EMEDIUMTYPE ? */
 
-	cqr = dasd_kmalloc_request("ECKD", 1 /* SNSS */,
+	cqr = dasd_kmalloc_request(DASD_ECKD_MAGIC, 1 /* SNSS */,
 				   SNSS_DATA_SIZE, device);
 	if (IS_ERR(cqr))
 		return -ENOMEM;
Index: linux-sles11/drivers/s390/block/dasd_fba.c
===================================================================
--- linux-sles11.orig/drivers/s390/block/dasd_fba.c
+++ linux-sles11/drivers/s390/block/dasd_fba.c
@@ -148,7 +148,7 @@ dasd_fba_check_characteristics(struct da
 
 	/* Read Device Characteristics */
 	rdc_data = (void *) &(private->rdc_data);
-	rc = dasd_generic_read_dev_chars(device, "FBA ", &rdc_data, 32);
+	rc = dasd_generic_read_dev_chars(device, DASD_FBA_MAGIC, &rdc_data, 32);
 	if (rc) {
 		DEV_MESSAGE(KERN_WARNING, device,
 			    "Read device characteristics returned error %d",
@@ -298,8 +298,7 @@ static struct dasd_ccw_req *dasd_fba_bui
 		datasize += (count - 1)*sizeof(struct LO_fba_data);
 	}
 	/* Allocate the ccw request. */
-	cqr = dasd_smalloc_request(dasd_fba_discipline.name,
-				   cplength, datasize, memdev);
+	cqr = dasd_smalloc_request(DASD_FBA_MAGIC, cplength, datasize, memdev);
 	if (IS_ERR(cqr))
 		return cqr;
 	ccw = cqr->cpaddr;
Index: linux-sles11/drivers/s390/block/dasd_int.h
===================================================================
--- linux-sles11.orig/drivers/s390/block/dasd_int.h
+++ linux-sles11/drivers/s390/block/dasd_int.h
@@ -60,6 +60,11 @@
 #include <asm/dasd.h>
 #include <asm/idals.h>
 
+/* DASD discipline magic */
+#define DASD_ECKD_MAGIC 0xC5C3D2C4
+#define DASD_DIAG_MAGIC 0xC4C9C1C7
+#define DASD_FBA_MAGIC 0xC6C2C140
+
 /*
  * SECTION: Type definitions
  */
@@ -528,9 +533,9 @@ extern struct block_device_operations da
 extern struct kmem_cache *dasd_page_cache;
 
 struct dasd_ccw_req *
-dasd_kmalloc_request(char *, int, int, struct dasd_device *);
+dasd_kmalloc_request(int , int, int, struct dasd_device *);
 struct dasd_ccw_req *
-dasd_smalloc_request(char *, int, int, struct dasd_device *);
+dasd_smalloc_request(int , int, int, struct dasd_device *);
 void dasd_kfree_request(struct dasd_ccw_req *, struct dasd_device *);
 void dasd_sfree_request(struct dasd_ccw_req *, struct dasd_device *);
 
@@ -572,7 +577,7 @@ int dasd_generic_set_offline (struct ccw
 int dasd_generic_notify(struct ccw_device *, int);
 void dasd_generic_handle_state_change(struct dasd_device *);
 
-int dasd_generic_read_dev_chars(struct dasd_device *, char *, void **, int);
+int dasd_generic_read_dev_chars(struct dasd_device *, int, void **, int);
 
 /* externals in dasd_devmap.c */
 extern int dasd_max_devindex;
