From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: kernel: appldata vtimer bug with cpu hotplug
References: bnc#487755,LTC#52680

Symptom:     Kernel BUG on SLES 11 with cpu hotplug and appldata timer enabled.
             On older distributions, the appldata interval will not expire
             correctly instead (interval may be longer after cpu hotplug).
Problem:     The mod_virt_timer() function will add a one-shot timer for new
             cpus, not an interval timer. Also, on SLES 11 there is a misplaced
             BUG_ON() statement in that function.
Solution:    Work around by adding a new vtimer for cpus that get online,
             before modifying it.

Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/appldata/appldata_base.c |   11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

Index: linux-sles11/arch/s390/appldata/appldata_base.c
===================================================================
--- linux-sles11.orig/arch/s390/appldata/appldata_base.c
+++ linux-sles11/arch/s390/appldata/appldata_base.c
@@ -478,13 +478,22 @@ void appldata_unregister_ops(struct appl
 
 static void __cpuinit appldata_online_cpu(int cpu)
 {
+	u64 per_cpu_interval;
+
 	init_virt_timer(&per_cpu(appldata_timer, cpu));
 	per_cpu(appldata_timer, cpu).function = appldata_timer_function;
 	per_cpu(appldata_timer, cpu).data = (unsigned long)
 		&appldata_work;
 	atomic_inc(&appldata_expire_count);
 	spin_lock(&appldata_timer_lock);
-	__appldata_vtimer_setup(APPLDATA_MOD_TIMER);
+	if (appldata_timer_active) {
+		per_cpu_interval = (u64) (appldata_interval * 1000 /
+					  num_online_cpus()) * TOD_MICRO;
+		per_cpu(appldata_timer, cpu).expires = per_cpu_interval;
+		smp_call_function_single(cpu, add_virt_timer_periodic,
+					 &per_cpu(appldata_timer, cpu), 1);
+		__appldata_vtimer_setup(APPLDATA_MOD_TIMER);
+	}
 	spin_unlock(&appldata_timer_lock);
 }
 
