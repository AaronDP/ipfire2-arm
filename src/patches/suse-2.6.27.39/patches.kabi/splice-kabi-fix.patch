From: Miklos Szeredi <mszeredi@suse.cz>
Subject: fix kabi breakage from i_mutex locking fix
Patch-mainline: no
References: bnc#495065

Splice splice_desc into two structures, splice_desc (the old version)
and splice_desc_ext, containing the new fields.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/ocfs2/file.c        |   18 +++++++++--------
 fs/splice.c            |   51 ++++++++++++++++++++++++++-----------------------
 include/linux/splice.h |   12 +++++++----
 3 files changed, 46 insertions(+), 35 deletions(-)

--- a/fs/ocfs2/file.c
+++ b/fs/ocfs2/file.c
@@ -2077,9 +2077,10 @@ out_sems:
 
 static int ocfs2_splice_to_file(struct pipe_inode_info *pipe,
 				struct file *out,
-				struct splice_desc *sd)
+				struct splice_desc_ext *esd)
 {
 	int ret;
+	struct splice_desc *sd = esd->sd;
 
 	ret = ocfs2_prepare_inode_for_write(out->f_path.dentry,	&sd->pos,
 					    sd->total_len, 0, NULL);
@@ -2088,7 +2089,7 @@ static int ocfs2_splice_to_file(struct p
 		return ret;
 	}
 
-	return splice_from_pipe_feed(pipe, sd, pipe_to_file);
+	return splice_from_pipe_feed(pipe, esd, pipe_to_file);
 }
 
 static ssize_t ocfs2_file_splice_write(struct pipe_inode_info *pipe,
@@ -2106,6 +2107,7 @@ static ssize_t ocfs2_file_splice_write(s
 		.pos = *ppos,
 		.u.file = out,
 	};
+	struct splice_desc_ext esd = { .sd = &sd };
 
 	mlog_entry("(0x%p, 0x%p, %u, '%.*s')\n", out, pipe,
 		   (unsigned int)len,
@@ -2115,9 +2117,9 @@ static ssize_t ocfs2_file_splice_write(s
 	if (pipe->inode)
 		mutex_lock_nested(&pipe->inode->i_mutex, I_MUTEX_PARENT);
 
-	splice_from_pipe_begin(&sd);
+	splice_from_pipe_begin(&esd);
 	do {
-		ret = splice_from_pipe_next(pipe, &sd);
+		ret = splice_from_pipe_next(pipe, &esd);
 		if (ret <= 0)
 			break;
 
@@ -2126,18 +2128,18 @@ static ssize_t ocfs2_file_splice_write(s
 		if (ret < 0)
 			mlog_errno(ret);
 		else {
-			ret = ocfs2_splice_to_file(pipe, out, &sd);
+			ret = ocfs2_splice_to_file(pipe, out, &esd);
 			ocfs2_rw_unlock(inode, 1);
 		}
 		mutex_unlock(&inode->i_mutex);
 	} while (ret > 0);
-	splice_from_pipe_end(pipe, &sd);
+	splice_from_pipe_end(pipe, &esd);
 
 	if (pipe->inode)
 		mutex_unlock(&pipe->inode->i_mutex);
 
-	if (sd.num_spliced)
-		ret = sd.num_spliced;
+	if (esd.num_spliced)
+		ret = esd.num_spliced;
 
 	if (ret > 0) {
 		unsigned long nr_pages;
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -629,10 +629,11 @@ static void wakeup_pipe_writers(struct p
  *    locking is required around copying the pipe buffers to the
  *    destination.
  */
-int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,
+int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc_ext *esd,
 			  splice_actor *actor)
 {
 	int ret;
+	struct splice_desc *sd = esd->sd;
 
 	while (pipe->nrbufs) {
 		struct pipe_buffer *buf = pipe->bufs + pipe->curbuf;
@@ -651,7 +652,7 @@ int splice_from_pipe_feed(struct pipe_in
 		buf->offset += ret;
 		buf->len -= ret;
 
-		sd->num_spliced += ret;
+		esd->num_spliced += ret;
 		sd->len -= ret;
 		sd->pos += ret;
 		sd->total_len -= ret;
@@ -662,7 +663,7 @@ int splice_from_pipe_feed(struct pipe_in
 			pipe->curbuf = (pipe->curbuf + 1) & (PIPE_BUFFERS - 1);
 			pipe->nrbufs--;
 			if (pipe->inode)
-				sd->need_wakeup = true;
+				esd->need_wakeup = true;
 		}
 
 		if (!sd->total_len)
@@ -683,13 +684,15 @@ EXPORT_SYMBOL(splice_from_pipe_feed);
  *    value (one) if pipe buffers are available.  It will return zero
  *    or -errno if no more data needs to be spliced.
  */
-int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)
+int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc_ext *esd)
 {
+	struct splice_desc *sd = esd->sd;
+
 	while (!pipe->nrbufs) {
 		if (!pipe->writers)
 			return 0;
 
-		if (!pipe->waiting_writers && sd->num_spliced)
+		if (!pipe->waiting_writers && esd->num_spliced)
 			return 0;
 
 		if (sd->flags & SPLICE_F_NONBLOCK)
@@ -698,9 +701,9 @@ int splice_from_pipe_next(struct pipe_in
 		if (signal_pending(current))
 			return -ERESTARTSYS;
 
-		if (sd->need_wakeup) {
+		if (esd->need_wakeup) {
 			wakeup_pipe_writers(pipe);
-			sd->need_wakeup = false;
+			esd->need_wakeup = false;
 		}
 
 		pipe_wait(pipe);
@@ -719,10 +722,10 @@ EXPORT_SYMBOL(splice_from_pipe_next);
  *    splice_from_pipe_next() and splice_from_pipe_feed() to
  *    initialize the necessary fields of @sd.
  */
-void splice_from_pipe_begin(struct splice_desc *sd)
+void splice_from_pipe_begin(struct splice_desc_ext *esd)
 {
-	sd->num_spliced = 0;
-	sd->need_wakeup = false;
+	esd->num_spliced = 0;
+	esd->need_wakeup = false;
 }
 EXPORT_SYMBOL(splice_from_pipe_begin);
 
@@ -736,9 +739,9 @@ EXPORT_SYMBOL(splice_from_pipe_begin);
  *    be called after a loop containing splice_from_pipe_next() and
  *    splice_from_pipe_feed().
  */
-void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)
+void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc_ext *esd)
 {
-	if (sd->need_wakeup)
+	if (esd->need_wakeup)
 		wakeup_pipe_writers(pipe);
 }
 EXPORT_SYMBOL(splice_from_pipe_end);
@@ -760,16 +763,17 @@ ssize_t __splice_from_pipe(struct pipe_i
 			   splice_actor *actor)
 {
 	int ret;
+	struct splice_desc_ext esd = { .sd = sd };
 
-	splice_from_pipe_begin(sd);
+	splice_from_pipe_begin(&esd);
 	do {
-		ret = splice_from_pipe_next(pipe, sd);
+		ret = splice_from_pipe_next(pipe, &esd);
 		if (ret > 0)
-			ret = splice_from_pipe_feed(pipe, sd, actor);
+			ret = splice_from_pipe_feed(pipe, &esd, actor);
 	} while (ret > 0);
-	splice_from_pipe_end(pipe, sd);
+	splice_from_pipe_end(pipe, &esd);
 
-	return sd->num_spliced ? sd->num_spliced : ret;
+	return esd.num_spliced ? esd.num_spliced : ret;
 }
 EXPORT_SYMBOL(__splice_from_pipe);
 
@@ -892,30 +896,31 @@ generic_file_splice_write(struct pipe_in
 		.pos = *ppos,
 		.u.file = out,
 	};
+	struct splice_desc_ext esd = { .sd = &sd };
 	ssize_t ret;
 
 	if (pipe->inode)
 		mutex_lock_nested(&pipe->inode->i_mutex, I_MUTEX_PARENT);
 
-	splice_from_pipe_begin(&sd);
+	splice_from_pipe_begin(&esd);
 	do {
-		ret = splice_from_pipe_next(pipe, &sd);
+		ret = splice_from_pipe_next(pipe, &esd);
 		if (ret <= 0)
 			break;
 
 		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
 		ret = file_remove_suid(out);
 		if (!ret)
-			ret = splice_from_pipe_feed(pipe, &sd, pipe_to_file);
+			ret = splice_from_pipe_feed(pipe, &esd, pipe_to_file);
 		mutex_unlock(&inode->i_mutex);
 	} while (ret > 0);
-	splice_from_pipe_end(pipe, &sd);
+	splice_from_pipe_end(pipe, &esd);
 
 	if (pipe->inode)
 		mutex_unlock(&pipe->inode->i_mutex);
 
-	if (sd.num_spliced)
-		ret = sd.num_spliced;
+	if (esd.num_spliced)
+		ret = esd.num_spliced;
 
 	if (ret > 0) {
 		unsigned long nr_pages;
--- a/include/linux/splice.h
+++ b/include/linux/splice.h
@@ -36,6 +36,10 @@ struct splice_desc {
 		void *data;		/* cookie */
 	} u;
 	loff_t pos;			/* file position */
+};
+
+struct splice_desc_ext {
+	struct splice_desc *sd;
 	size_t num_spliced;		/* number of bytes already spliced */
 	bool need_wakeup;		/* need to wake up writer */
 };
@@ -68,13 +72,13 @@ extern ssize_t splice_from_pipe(struct p
 				splice_actor *);
 extern ssize_t __splice_from_pipe(struct pipe_inode_info *,
 				  struct splice_desc *, splice_actor *);
-extern int splice_from_pipe_feed(struct pipe_inode_info *, struct splice_desc *,
+extern int splice_from_pipe_feed(struct pipe_inode_info *, struct splice_desc_ext *,
 				 splice_actor *);
 extern int splice_from_pipe_next(struct pipe_inode_info *,
-				 struct splice_desc *);
-extern void splice_from_pipe_begin(struct splice_desc *);
+				 struct splice_desc_ext *);
+extern void splice_from_pipe_begin(struct splice_desc_ext *);
 extern void splice_from_pipe_end(struct pipe_inode_info *,
-				 struct splice_desc *);
+				 struct splice_desc_ext *);
 extern int pipe_to_file(struct pipe_inode_info *, struct pipe_buffer *,
 			struct splice_desc *);
 
