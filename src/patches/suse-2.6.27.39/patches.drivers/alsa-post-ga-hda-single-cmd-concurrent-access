From: Takashi Iwai <tiwai@suse.de>
Subject: ALSA: hda - Allow concurrent RIRB access in single_cmd mode
Patch-mainline: 
References: bnc#502903

In the single_cmd mode, the current driver code doesn't do any update
for RIRB just for any safety reason.  But, actually the RIRB and
single_cmd mode don't conflict.  Unsolicited events can be delivered
even while using the single_cmd mode.

This patch allows the handling of unsolicited events with single_cmd
mode, just always checking RIRB independent from single_cmd flag.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/pci/hda/hda_intel.c |   13 +++++--------
 1 file changed, 5 insertions(+), 8 deletions(-)

--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -868,8 +868,7 @@ static void azx_init_chip(struct azx *ch
 	azx_int_enable(chip);
 
 	/* initialize the codec command I/O */
-	if (!chip->single_cmd)
-		azx_init_cmd_io(chip);
+	azx_init_cmd_io(chip);
 
 	/* program the position buffer */
 	azx_writel(chip, DPLBASE, (u32)chip->posbuf.addr);
@@ -989,7 +988,7 @@ static irqreturn_t azx_interrupt(int irq
 	/* clear rirb int */
 	status = azx_readb(chip, RIRBSTS);
 	if (status & RIRB_INT_MASK) {
-		if (!chip->single_cmd && (status & RIRB_INT_RESPONSE))
+		if (status & RIRB_INT_RESPONSE)
 			azx_update_rirb(chip);
 		azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
 	}
@@ -2272,11 +2271,9 @@ static int __devinit azx_create(struct s
 		goto errout;
 	}
 	/* allocate CORB/RIRB */
-	if (!chip->single_cmd) {
-		err = azx_alloc_cmd_io(chip);
-		if (err < 0)
-			goto errout;
-	}
+	err = azx_alloc_cmd_io(chip);
+	if (err < 0)
+		goto errout;
 
 	/* initialize streams */
 	azx_init_stream(chip);
