# patch found at http://freiburg.linux.de/~zeisberg/howtos/fritzcarddsl.html
--- fritz.old/src.drv/driver.c.orig	2003-12-19 00:00:00.000000000 +0200
+++ fritz/src.drv/driver.c	2004-07-18 17:03:36.000000000 +0200
@@ -18,6 +18,14 @@
  * http://www.opensource.org/licenses/lgpl-license.html
  * 
  * Contact: AVM GmbH, Alt-Moabit 95, 10559 Berlin, Germany, email: info@avm.de
+ *
+ * Sunday Dec 07 18:10 2003
+ * Modified by Christian 'greeny' Heckhoff to improve locking
+ * based on modifications by Joerg Lehrke for Fritz!Card DSL
+ *
+ * Saturday Jul 24 2004, Oswin Horvath 
+ * small modifications to make the patch work for the Fritz!Card SL USB (03.11.94)
+ * 
  */
 
 #include <asm/io.h>
@@ -54,6 +62,8 @@
 #include "devif.h"
 #include "driver.h"
 
+#undef SINGLE_LOCK
+
 #if defined (LOG_MESSAGES)
 # define mlog		log
 #else
@@ -118,7 +128,11 @@
 static bundle_t			ctrl_context[2];
 static per_ctrl_t		ctrl_params[2];
 static unsigned long		qt_flags;
+#if defined (SINGLE_LOCK)
+# define stack_lock qt_lock
+#else
 static spinlock_t		qt_lock			= SPIN_LOCK_UNLOCKED;
+#endif
 static atomic_t			thread_flag		= ATOMIC_INIT (0);
 static atomic_t			thread_capi_flag	= ATOMIC_INIT (0);
 static int			thread_pid		= -1;
@@ -946,7 +960,7 @@
 } /* fdslusb_remove_ctrl */
 
 /*---------------------------------------------------------------------------*\
-\*-L-------------------------------------------------------------------------*/
+\*---------------------------------------------------------------------------*/
 void lock (void) {
 	unsigned long	local_flags;
 	
@@ -966,12 +980,17 @@
 /*---------------------------------------------------------------------------*\
 \*-C-------------------------------------------------------------------------*/
 static inline void check (void) {
+        unsigned long flags;
 
         if (atomic_read (&rx_flag) > 0) {
+	        spin_lock_irqsave (&stack_lock, flags);
 		rx_handler (fcslusb_capi_card);
+		spin_unlock_irqrestore (&stack_lock, flags);
 	}
 	if (atomic_read (&tx_flag) > 0) {
+	        spin_lock_irqsave (&stack_lock, flags);
 		tx_handler (fcslusb_capi_card);
+		spin_unlock_irqrestore (&stack_lock, flags);
 	}
 } /* check */
 
@@ -1519,6 +1538,7 @@
 /*-S-------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/
 static int scheduler (void * arg) {
+        unsigned long flags;
 
 	UNUSED_ARG (arg);
 	daemonize ();
@@ -1551,6 +1571,7 @@
 			continue;
 		}
 		/* Body of thread, invoke scheduler */
+		local_irq_save(flags);
 		if (spin_trylock (&stack_lock)) {
 			info (!atomic_xchg (&in_scheduler, 1));
 			os_timer_poll ();
@@ -1561,6 +1582,7 @@
 			debug (atomic_set (&in_scheduler, 0));
 			spin_unlock (&stack_lock);
 		}
+		local_irq_restore(flags);
 	}
 	log ("Scheduler thread stopped.\n");
 	up (&thread_sync);
@@ -1743,22 +1765,43 @@
 /*---------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/ 
 static void tx_task (unsigned long data) {
-
+	unsigned long flags;  
 	UNUSED_ARG (data);
-	if (!in_critical () && spin_trylock (&stack_lock)) {
-		tx_handler (fcslusb_capi_card);
-		spin_unlock (&stack_lock);
+	
+	if (in_critical ()){
+		atomic_set (&tx_flag, 1);
+		kick_scheduler ();
+	} else {
+		local_irq_save(flags);
+		if (spin_trylock (&stack_lock)) {
+			tx_handler (fcslusb_capi_card);
+			spin_unlock (&stack_lock);
+		} else {
+			atomic_set (&tx_flag, 1);
+			kick_scheduler ();
+		}
+		local_irq_restore(flags);
 	}
 } /* tx_task */
 
 /*---------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/ 
 static void rx_task (unsigned long data) {
-
+	unsigned long flags;
 	UNUSED_ARG (data);
-	if (!in_critical () && spin_trylock (&stack_lock)) {
-		rx_handler (fcslusb_capi_card);
-		spin_unlock (&stack_lock);
+	if (in_critical ()){
+		atomic_set (&rx_flag, 1);
+		kick_scheduler ();
+	} else {
+		local_irq_save(flags);
+		if (spin_trylock (&stack_lock)) {
+			rx_handler (fcslusb_capi_card);
+			spin_unlock (&stack_lock);
+		} else {
+			atomic_set (&rx_flag, 1);
+			kick_scheduler ();
+		}
+		local_irq_restore(flags);
 	}
 } /* rx_task */
 
