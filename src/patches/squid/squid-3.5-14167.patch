------------------------------------------------------------
revno: 14167
revision-id: squid3@treenet.co.nz-20170529131555-kut221f3geb3aczf
parent: squid3@treenet.co.nz-20170529125748-qt7yhdloygl4xosg
fixes bug: http://bugs.squid-cache.org/show_bug.cgi?id=4653
author: Christos Tsantilas <chtsanti@users.sourceforge.net>
committer: Amos Jeffries <squid3@treenet.co.nz>
branch nick: 3.5
timestamp: Tue 2017-05-30 01:15:55 +1200
message:
  Bug 4653: %st lies about tunneled traffic volumes
  
  Squid-3.5 counts only the "CONNECT ..." header size for %>st and does not
  count the "HTTP/1.1 200" response header for the %<st.
  
  This is a Measurement Factory project
------------------------------------------------------------
# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: squid3@treenet.co.nz-20170529131555-kut221f3geb3aczf
# target_branch: http://bzr.squid-cache.org/bzr/squid3/3.5
# testament_sha1: dd5783b425c7c7125303a1bd1a5685bc28011754
# timestamp: 2017-05-29 13:51:09 +0000
# source_branch: http://bzr.squid-cache.org/bzr/squid3/3.5
# base_revision_id: squid3@treenet.co.nz-20170529125748-\
#   qt7yhdloygl4xosg
# 
# Begin patch
=== modified file 'src/client_side.cc'
--- src/client_side.cc	2017-03-31 00:51:52 +0000
+++ src/client_side.cc	2017-05-29 13:15:55 +0000
@@ -4391,7 +4391,7 @@
             // in.buf still has the "CONNECT ..." request data, reset it to SSL hello message
             connState->in.buf.append(rbuf.content(), rbuf.contentSize());
             ClientHttpRequest *http = context->http;
-            tunnelStart(http, &http->out.size, &http->al->http.code, http->al);
+            tunnelStart(http);
         }
     }
 }

=== modified file 'src/client_side_reply.cc'
--- src/client_side_reply.cc	2017-01-01 00:16:45 +0000
+++ src/client_side_reply.cc	2017-05-29 13:15:55 +0000
@@ -1179,7 +1179,7 @@
     if (curReply->content_length < 0)
         return 0;
 
-    int64_t expectedLength = curReply->content_length + http->out.headers_sz;
+    uint64_t expectedLength = curReply->content_length + http->out.headers_sz;
 
     if (http->out.size < expectedLength)
         return 0;

=== modified file 'src/client_side_request.cc'
--- src/client_side_request.cc	2017-05-29 07:10:37 +0000
+++ src/client_side_request.cc	2017-05-29 13:15:55 +0000
@@ -1522,7 +1522,7 @@
         }
 #endif
         getConn()->stopReading(); // tunnels read for themselves
-        tunnelStart(this, &out.size, &al->http.code, al);
+        tunnelStart(this);
         return;
     }
 

=== modified file 'src/client_side_request.h'
--- src/client_side_request.h	2017-01-23 02:05:46 +0000
+++ src/client_side_request.h	2017-05-29 13:15:55 +0000
@@ -73,7 +73,7 @@
 
     struct {
         int64_t offset;
-        int64_t size;
+        uint64_t size;
         size_t headers_sz;
     } out;
 
@@ -182,7 +182,7 @@
 void clientAccessCheck(ClientHttpRequest *);
 
 /* ones that should be elsewhere */
-void tunnelStart(ClientHttpRequest *, int64_t *, int *, const AccessLogEntry::Pointer &al);
+void tunnelStart(ClientHttpRequest *);
 
 #if _USE_INLINE_
 #include "client_side_request.cci"

=== modified file 'src/tests/stub_tunnel.cc'
--- src/tests/stub_tunnel.cc	2017-01-01 00:16:45 +0000
+++ src/tests/stub_tunnel.cc	2017-05-29 13:15:55 +0000
@@ -14,7 +14,7 @@
 #include "FwdState.h"
 class ClientHttpRequest;
 
-void tunnelStart(ClientHttpRequest *, int64_t *, int *, const AccessLogEntryPointer &al) STUB
+void tunnelStart(ClientHttpRequest *) STUB
 
 void switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::ConnectionPointer &srvConn) STUB
 

=== modified file 'src/tunnel.cc'
--- src/tunnel.cc	2017-05-29 12:57:48 +0000
+++ src/tunnel.cc	2017-05-29 13:15:55 +0000
@@ -139,7 +139,7 @@
         int len;
         char *buf;
         AsyncCall::Pointer writer; ///< pending Comm::Write callback
-        int64_t *size_ptr;      /* pointer to size in an ConnStateData for logging */
+        uint64_t *size_ptr;      /* pointer to size in an ConnStateData for logging */
 
         Comm::ConnectionPointer conn;    ///< The currently connected connection.
         uint8_t delayedLoops; ///< how many times a read on this connection has been postponed.
@@ -848,6 +848,11 @@
         return;
     }
 
+    if (ClientHttpRequest *http = tunnelState->http.get()) {
+        http->out.headers_sz += size;
+        http->out.size += size;
+    }
+
     tunnelStartShoveling(tunnelState);
 }
 
@@ -995,7 +1000,7 @@
 }
 
 void
-tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const AccessLogEntryPointer &al)
+tunnelStart(ClientHttpRequest * http)
 {
     debugs(26, 3, HERE);
     /* Create state structure. */
@@ -1021,7 +1026,7 @@
         if (ch.fastCheck() == ACCESS_DENIED) {
             debugs(26, 4, HERE << "MISS access forbidden.");
             err = new ErrorState(ERR_FORWARDING_DENIED, Http::scForbidden, request);
-            *status_ptr = Http::scForbidden;
+            http->al->http.code = Http::scForbidden;
             errorSend(http->getConn()->clientConnection, err);
             return;
         }
@@ -1037,12 +1042,13 @@
 #endif
     tunnelState->url = xstrdup(url);
     tunnelState->request = request;
-    tunnelState->server.size_ptr = size_ptr;
-    tunnelState->status_ptr = status_ptr;
+    tunnelState->server.size_ptr = &http->out.size;
+    tunnelState->client.size_ptr = &http->al->http.clientRequestSz.payloadData;
+    tunnelState->status_ptr = &http->al->http.code;
     tunnelState->logTag_ptr = &http->logType;
     tunnelState->client.conn = http->getConn()->clientConnection;
     tunnelState->http = http;
-    tunnelState->al = al;
+    tunnelState->al = http->al ;
     tunnelState->started = squid_curtime;
 
     comm_add_close_handler(tunnelState->client.conn->fd,
@@ -1053,7 +1059,7 @@
                                      CommTimeoutCbPtrFun(tunnelTimeout, tunnelState));
     commSetConnTimeout(tunnelState->client.conn, Config.Timeout.lifetime, timeoutCall);
 
-    peerSelect(&(tunnelState->serverDestinations), request, al,
+    peerSelect(&(tunnelState->serverDestinations), request, tunnelState->al,
                NULL,
                tunnelPeerSelectComplete,
                tunnelState);
@@ -1226,6 +1232,10 @@
         if (context != NULL && context->http != NULL) {
             tunnelState->logTag_ptr = &context->http->logType;
             tunnelState->server.size_ptr = &context->http->out.size;
+            if (context->http->al != NULL) {
+                tunnelState->al = context->http->al;
+                tunnelState->client.size_ptr = &context->http->al->http.clientRequestSz.payloadData;
+            }
 
 #if USE_DELAY_POOLS
             /* no point using the delayIsNoDelay stuff since tunnel is nice and simple */

