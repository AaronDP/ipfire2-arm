From: Youquan Song <youquan.song@intel.com>
Subject: x86: Fix APICID panic
References: bnc#502026

Signed-off-by: Rafael J. Wysocki <rjw@suse.de>

---
 arch/x86/kernel/apic_64.c           |   12 ++++++++++++
 arch/x86/kernel/genapic_64.c        |   10 ++++++++++
 arch/x86/kernel/genx2apic_cluster.c |    5 +----
 arch/x86/kernel/genx2apic_phys.c    |   10 +++++-----
 include/asm-x86/apic.h              |   10 +++++++++-
 5 files changed, 37 insertions(+), 10 deletions(-)

--- a/arch/x86/kernel/apic_64.c
+++ b/arch/x86/kernel/apic_64.c
@@ -928,6 +928,18 @@ void enable_x2apic(void)
 	}
 }
 
+int x2apic_enabled(void)
+{
+	int msr, msr2;
+	if (!cpu_has_x2apic)
+		return 0;
+
+	rdmsr(MSR_IA32_APICBASE, msr, msr2);
+	if (msr & X2APIC_ENABLE)
+		return 1;
+	return 0;
+}
+
 void __init enable_IR_x2apic(void)
 {
 #ifdef CONFIG_INTR_REMAP
--- a/arch/x86/kernel/genapic_64.c
+++ b/arch/x86/kernel/genapic_64.c
@@ -48,6 +48,16 @@ void __init setup_apic_routing(void)
 			genapic = &apic_flat;
 	}
 
+	if (x2apic && (genapic != &apic_x2apic_phys &&
+			genapic != &apic_x2apic_uv_x &&
+			genapic != &apic_x2apic_cluster)) {
+		if (x2apic_phys)
+			genapic = &apic_x2apic_phys;
+		else
+			genapic = &apic_x2apic_cluster;
+		printk(KERN_INFO "Setting APIC routing to %s\n", genapic->name);
+	}
+
 	if (genapic == &apic_flat) {
 		if (max_physical_apicid >= 8)
 			genapic = &apic_physflat;
--- a/arch/x86/kernel/genx2apic_cluster.c
+++ b/arch/x86/kernel/genx2apic_cluster.c
@@ -14,10 +14,7 @@ DEFINE_PER_CPU(u32, x86_cpu_to_logical_a
 
 static int x2apic_acpi_madt_oem_check(char *oem_id, char *oem_table_id)
 {
-	if (cpu_has_x2apic)
-		return 1;
-
-	return 0;
+	return x2apic_enabled();
 }
 
 /* Start with all IRQs pointing to boot CPU.  IRQ balancing will shift them. */
--- a/arch/x86/kernel/genx2apic_phys.c
+++ b/arch/x86/kernel/genx2apic_phys.c
@@ -12,7 +12,7 @@
 
 DEFINE_PER_CPU(int, x2apic_extra_bits);
 
-static int x2apic_phys;
+int x2apic_phys;
 
 static int set_x2apic_phys_mode(char *arg)
 {
@@ -23,10 +23,10 @@ early_param("x2apic_phys", set_x2apic_ph
 
 static int x2apic_acpi_madt_oem_check(char *oem_id, char *oem_table_id)
 {
-	if (cpu_has_x2apic && x2apic_phys)
-		return 1;
-
-	return 0;
+	if (x2apic_phys)
+		return x2apic_enabled();
+	else
+		return 0;
 }
 
 /* Start with all IRQs pointing to boot CPU.  IRQ balancing will shift them. */
--- a/include/asm-x86/apic.h
+++ b/include/asm-x86/apic.h
@@ -90,11 +90,19 @@ static inline u32 native_apic_msr_read(u
 }
 
 #ifndef CONFIG_X86_32
- extern int x2apic, x2apic_preenabled;
+ extern int x2apic, x2apic_preenabled, x2apic_phys;
  extern void check_x2apic(void);
  extern void enable_x2apic(void);
+ extern int x2apic_enabled(void);
  extern void enable_IR_x2apic(void);
  extern void x2apic_icr_write(u32 low, u32 id);
+#else
+ #define x2apic 0
+ #define x2apic_phys 0
+static inline int x2apic_enabled(void)
+{
+	return 0;
+}
 #endif
 
 struct apic_ops {
