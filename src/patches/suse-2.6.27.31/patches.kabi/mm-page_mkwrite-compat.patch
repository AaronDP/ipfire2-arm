From: Nick Piggin <npiggin@suse.de>
Subject: mm: page_mkwrite kABI compat 2
Patch-upstream: never

Introduce a new vma flag, VM_PAGE_MKWRITE2, which signals to the mm that the
driver is using page_mkwrite2. Have all in-tree users set this flag because
they use page_mkwrite2.  Introduce some fallback paths in the page fault
page_mkwrite callers which calls the old page_mkwrite in case this flag is not
set. In this way, ABI compatibility should be retained for out of tree modules.

We also now do some extra checking in the fallback case to catch page
invalidations and just retry the fault rather than erroneously causing a
SIGBUS, which was one of the failure cases of the old page_mkwrite ABI (it
still has other problems, but this was one of the worst).

Signed-off-by: Nick Piggin <npiggin@suse.de>
---
 drivers/video/fb_defio.c    |    2 -
 fs/ext4/file.c              |    2 -
 fs/fuse/file.c              |    1 
 fs/gfs2/ops_file.c          |    1 
 fs/nfs/file.c               |    2 -
 fs/ocfs2/mmap.c             |    2 -
 fs/ubifs/file.c             |    1 
 fs/xfs/linux-2.6/xfs_file.c |    2 -
 include/linux/mm.h          |    1 
 mm/memory.c                 |   77 ++++++++++++++++++++++++++++++++------------
 10 files changed, 66 insertions(+), 25 deletions(-)

Index: linux-2.6.27/drivers/video/fb_defio.c
===================================================================
--- linux-2.6.27.orig/drivers/video/fb_defio.c
+++ linux-2.6.27/drivers/video/fb_defio.c
@@ -129,7 +129,7 @@ static const struct address_space_operat
 static int fb_deferred_io_mmap(struct fb_info *info, struct vm_area_struct *vma)
 {
 	vma->vm_ops = &fb_deferred_io_vm_ops;
-	vma->vm_flags |= ( VM_IO | VM_RESERVED | VM_DONTEXPAND );
+	vma->vm_flags |= ( VM_IO | VM_RESERVED | VM_DONTEXPAND | VM_PAGE_MKWRITE2 );
 	vma->vm_private_data = info;
 	return 0;
 }
Index: linux-2.6.27/fs/ext4/file.c
===================================================================
--- linux-2.6.27.orig/fs/ext4/file.c
+++ linux-2.6.27/fs/ext4/file.c
@@ -136,7 +136,7 @@ static int ext4_file_mmap(struct file *f
 		return -ENOEXEC;
 	file_accessed(file);
 	vma->vm_ops = &ext4_file_vm_ops;
-	vma->vm_flags |= VM_CAN_NONLINEAR;
+	vma->vm_flags |= VM_CAN_NONLINEAR | VM_PAGE_MKWRITE2;
 	return 0;
 }
 
Index: linux-2.6.27/fs/fuse/file.c
===================================================================
--- linux-2.6.27.orig/fs/fuse/file.c
+++ linux-2.6.27/fs/fuse/file.c
@@ -1255,6 +1255,7 @@ static int fuse_file_mmap(struct file *f
 		spin_unlock(&fc->lock);
 	}
 	file_accessed(file);
+	vma->vm_flags |= VM_PAGE_MKWRITE2;
 	vma->vm_ops = &fuse_file_vm_ops;
 	return 0;
 }
Index: linux-2.6.27/fs/gfs2/ops_file.c
===================================================================
--- linux-2.6.27.orig/fs/gfs2/ops_file.c
+++ linux-2.6.27/fs/gfs2/ops_file.c
@@ -446,6 +446,7 @@ static int gfs2_mmap(struct file *file,
 		return error;
 	}
 
+	vma->vm_flags |= VM_PAGE_MKWRITE2;
 	vma->vm_ops = &gfs2_vm_ops;
 
 	gfs2_glock_dq_uninit(&i_gh);
Index: linux-2.6.27/fs/nfs/file.c
===================================================================
--- linux-2.6.27.orig/fs/nfs/file.c
+++ linux-2.6.27/fs/nfs/file.c
@@ -304,7 +304,7 @@ nfs_file_mmap(struct file * file, struct
 	status = nfs_revalidate_mapping(inode, file->f_mapping);
 	if (!status) {
 		vma->vm_ops = &nfs_file_vm_ops;
-		vma->vm_flags |= VM_CAN_NONLINEAR;
+		vma->vm_flags |= VM_CAN_NONLINEAR | VM_PAGE_MKWRITE2;
 		file_accessed(file);
 	}
 	return status;
Index: linux-2.6.27/fs/ocfs2/mmap.c
===================================================================
--- linux-2.6.27.orig/fs/ocfs2/mmap.c
+++ linux-2.6.27/fs/ocfs2/mmap.c
@@ -216,7 +216,7 @@ int ocfs2_mmap(struct file *file, struct
 	ocfs2_inode_unlock(file->f_dentry->d_inode, lock_level);
 out:
 	vma->vm_ops = &ocfs2_file_vm_ops;
-	vma->vm_flags |= VM_CAN_NONLINEAR;
+	vma->vm_flags |= VM_CAN_NONLINEAR | VM_PAGE_MKWRITE2;
 	return 0;
 }
 
Index: linux-2.6.27/fs/ubifs/file.c
===================================================================
--- linux-2.6.27.orig/fs/ubifs/file.c
+++ linux-2.6.27/fs/ubifs/file.c
@@ -1246,6 +1246,7 @@ static int ubifs_file_mmap(struct file *
 	if (err)
 		return err;
 	vma->vm_ops = &ubifs_file_vm_ops;
+	vma->vm_flags |= VM_PAGE_MKWRITE2;
 	return 0;
 }
 
Index: linux-2.6.27/fs/xfs/linux-2.6/xfs_file.c
===================================================================
--- linux-2.6.27.orig/fs/xfs/linux-2.6/xfs_file.c
+++ linux-2.6.27/fs/xfs/linux-2.6/xfs_file.c
@@ -370,7 +370,7 @@ xfs_file_mmap(
 	struct vm_area_struct *vma)
 {
 	vma->vm_ops = &xfs_file_vm_ops;
-	vma->vm_flags |= VM_CAN_NONLINEAR;
+	vma->vm_flags |= VM_CAN_NONLINEAR | VM_PAGE_MKWRITE2;
 
 	file_accessed(filp);
 	return 0;
Index: linux-2.6.27/include/linux/mm.h
===================================================================
--- linux-2.6.27.orig/include/linux/mm.h
+++ linux-2.6.27/include/linux/mm.h
@@ -113,6 +113,7 @@ extern unsigned int kobjsize(const void
 #define VM_CAN_NONLINEAR 0x08000000	/* Has ->fault & does nonlinear pages */
 #define VM_MIXEDMAP	0x10000000	/* Can contain "struct page" and pure PFN pages */
 #define VM_SAO		0x20000000	/* Strong Access Ordering (powerpc) */
+#define VM_PAGE_MKWRITE2 0x80000000	/* Uses page_mkwrite2 rather than page_mkwrite */
 
 #ifndef VM_STACK_DEFAULT_FLAGS		/* arch can override this */
 #define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
Index: linux-2.6.27/mm/memory.c
===================================================================
--- linux-2.6.27.orig/mm/memory.c
+++ linux-2.6.27/mm/memory.c
@@ -1800,7 +1800,7 @@ static int do_wp_page(struct mm_struct *
 		 * read-only shared pages can get COWed by
 		 * get_user_pages(.write=1, .force=1).
 		 */
-		if (vma->vm_ops && vma->vm_ops->_pmkw.page_mkwrite2) {
+		if (vma->vm_ops && vma->vm_ops->_pmkw.page_mkwrite) {
 			struct vm_fault vmf;
 			int tmp;
 
@@ -1821,21 +1821,42 @@ static int do_wp_page(struct mm_struct *
 			page_cache_get(old_page);
 			pte_unmap_unlock(page_table, ptl);
 
-			tmp = vma->vm_ops->_pmkw.page_mkwrite2(vma, &vmf);
-			if (unlikely(tmp &
-					(VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {
-				ret = tmp;
-				goto unwritable_page;
-			}
-			if (unlikely(!(tmp & VM_FAULT_LOCKED))) {
+			if (likely(vma->vm_flags & VM_PAGE_MKWRITE2)) {
+				tmp = vma->vm_ops->_pmkw.page_mkwrite2(vma, &vmf);
+				if (unlikely(tmp &
+						(VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {
+					ret = tmp;
+					goto unwritable_page;
+				}
+				if (unlikely(!(tmp & VM_FAULT_LOCKED))) {
+					lock_page(old_page);
+					if (!old_page->mapping) {
+						ret = 0; /* retry the fault */
+						unlock_page(old_page);
+						goto unwritable_page;
+					}
+				} else
+					VM_BUG_ON(!PageLocked(old_page));
+			} else {
+				tmp = vma->vm_ops->_pmkw.page_mkwrite(vma, old_page);
 				lock_page(old_page);
 				if (!old_page->mapping) {
+					/*
+					 * page_mkwrite API is broken, it returns error even
+					 * if the page was invalidated. So if it was, then
+					 * clear that error here so we don't get a SIGBUS.
+					 */
 					ret = 0; /* retry the fault */
 					unlock_page(old_page);
 					goto unwritable_page;
 				}
-			} else
-				VM_BUG_ON(!PageLocked(old_page));
+				if (tmp) {
+					/* can't distinguish OOM from SIGBUS, but oh well */
+					ret = VM_FAULT_SIGBUS;
+					unlock_page(old_page);
+					goto unwritable_page;
+				}
+			}
 
 			/*
 			 * Since we dropped the lock we need to revalidate
@@ -2517,26 +2538,42 @@ static int __do_fault(struct mm_struct *
 			 * address space wants to know that the page is about
 			 * to become writable
 			 */
-			if (vma->vm_ops->_pmkw.page_mkwrite2) {
+			if (vma->vm_ops->_pmkw.page_mkwrite) {
 				int tmp;
 
 				unlock_page(page);
 				vmf.flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;
-				tmp = vma->vm_ops->_pmkw.page_mkwrite2(vma, &vmf);
-				if (unlikely(tmp &
-					  (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {
-					ret = tmp;
-					goto unwritable_page;
-				}
-				if (unlikely(!(tmp & VM_FAULT_LOCKED))) {
+
+				if (likely(vma->vm_flags & VM_PAGE_MKWRITE2)) {
+					tmp = vma->vm_ops->_pmkw.page_mkwrite2(vma, &vmf);
+					if (unlikely(tmp &
+						  (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {
+						ret = tmp;
+						goto unwritable_page;
+					}
+					if (unlikely(!(tmp & VM_FAULT_LOCKED))) {
+						lock_page(page);
+						if (!page->mapping) {
+							ret = 0; /* retry the fault */
+							unlock_page(page);
+							goto unwritable_page;
+						}
+					} else
+						VM_BUG_ON(!PageLocked(page));
+				} else {
+					tmp = vma->vm_ops->_pmkw.page_mkwrite(vma, page);
 					lock_page(page);
 					if (!page->mapping) {
 						ret = 0; /* retry the fault */
 						unlock_page(page);
 						goto unwritable_page;
 					}
-				} else
-					VM_BUG_ON(!PageLocked(page));
+					if (tmp) {
+						ret = VM_FAULT_SIGBUS;
+						unlock_page(page);
+						goto unwritable_page;
+					}
+				}
 				page_mkwrite = 1;
 			}
 		}
