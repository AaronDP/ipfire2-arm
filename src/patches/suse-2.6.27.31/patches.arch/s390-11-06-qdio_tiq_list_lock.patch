From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: qdio: add missing tiq_list locking
References: bnc#484767,LTC#52205

Symptom:     The system may hang if multiple qdio devices are added or
             removed in parallel.
Problem:     Although reading the tiq_list is done using RCU adding and 
             removing elements from the list must still happen locked since
             multiple qdio devices may change the list in parallel otherwise.
Solution:    Add a mutex to protect the tiq_list.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/cio/qdio_main.c    |    1 +
 drivers/s390/cio/qdio_thinint.c |   10 +++++++---
 2 files changed, 8 insertions(+), 3 deletions(-)

Index: linux-sles11/drivers/s390/cio/qdio_main.c
===================================================================
--- linux-sles11.orig/drivers/s390/cio/qdio_main.c
+++ linux-sles11/drivers/s390/cio/qdio_main.c
@@ -1094,6 +1094,7 @@ int qdio_shutdown(struct ccw_device *cde
 	if (!irq_ptr)
 		return -ENODEV;
 
+	BUG_ON(irqs_disabled());
 	DBF_EVENT("qshutdown:%4x", cdev->private->schid.sch_no);
 
 	mutex_lock(&irq_ptr->setup_mutex);
Index: linux-sles11/drivers/s390/cio/qdio_thinint.c
===================================================================
--- linux-sles11.orig/drivers/s390/cio/qdio_thinint.c
+++ linux-sles11/drivers/s390/cio/qdio_thinint.c
@@ -31,6 +31,7 @@
 
 /* list of thin interrupt input queues */
 static LIST_HEAD(tiq_list);
+DEFINE_MUTEX(tiq_list_lock);
 
 /* adapter local summary indicator */
 static unsigned char *tiqdio_alsi;
@@ -95,10 +96,10 @@ void tiqdio_add_input_queues(struct qdio
 	if (!css_qdio_omit_svs && irq_ptr->siga_flag.sync)
 		css_qdio_omit_svs = 1;
 
-	for_each_input_queue(irq_ptr, q, i) {
+	mutex_lock(&tiq_list_lock);
+	for_each_input_queue(irq_ptr, q, i)
 		list_add_rcu(&q->entry, &tiq_list);
-		synchronize_rcu();
-	}
+	mutex_unlock(&tiq_list_lock);
 	xchg(irq_ptr->dsci, 1);
 	tasklet_schedule(&tiqdio_tasklet);
 }
@@ -118,7 +119,10 @@ void tiqdio_remove_input_queues(struct q
 		/* if establish triggered an error */
 		if (!q || !q->entry.prev || !q->entry.next)
 			continue;
+
+		mutex_lock(&tiq_list_lock);
 		list_del_rcu(&q->entry);
+		mutex_unlock(&tiq_list_lock);
 		synchronize_rcu();
 	}
 }
