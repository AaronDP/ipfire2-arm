From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: zfcp: Move scan_target to scsi host workqueue
References: bnc#484767,LTC#52236

Symptom:     Trying to attach a non-existing LUN blocks all state
             changes in the zfcp driver.
Problem:     If the storage server does not respond, the
             scsi_scan_target  call blocks until it reaches all
	     timeouts. This blocks all other tasks on the zfcp workqueue.
Solution:    Run the scsi_scan_target work on the scsi host
             workqueue, the same one where the scan from the SCSI
	     midlayer runs on.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/scsi/zfcp_aux.c  |    5 +---
 drivers/s390/scsi/zfcp_def.h  |    2 -
 drivers/s390/scsi/zfcp_erp.c  |   49 +++---------------------------------------
 drivers/s390/scsi/zfcp_ext.h  |    1 
 drivers/s390/scsi/zfcp_scsi.c |   14 ++++++++++++
 5 files changed, 22 insertions(+), 49 deletions(-)

--- a/drivers/s390/scsi/zfcp_aux.c	2009-03-16 16:41:33.000000000 +0100
+++ b/drivers/s390/scsi/zfcp_aux.c	2009-03-16 16:42:42.000000000 +0100
@@ -133,9 +133,7 @@ static void __init zfcp_init_device_conf
 	ccw_device_set_online(adapter->ccw_device);
 
 	zfcp_erp_wait(adapter);
-	wait_event(adapter->erp_done_wqh,
-		   !(atomic_read(&unit->status) &
-				ZFCP_STATUS_UNIT_SCSI_WORK_PENDING));
+	flush_work(&unit->scsi_work);
 
 	down(&zfcp_data.config_sema);
 	zfcp_unit_put(unit);
@@ -288,6 +286,7 @@ struct zfcp_unit *zfcp_unit_enqueue(stru
 
 	atomic_set(&unit->refcount, 0);
 	init_waitqueue_head(&unit->remove_wq);
+	INIT_WORK(&unit->scsi_work, zfcp_scsi_scan);
 
 	unit->port = port;
 	unit->fcp_lun = fcp_lun;
--- a/drivers/s390/scsi/zfcp_def.h	2009-03-16 16:41:33.000000000 +0100
+++ b/drivers/s390/scsi/zfcp_def.h	2009-03-16 16:43:18.000000000 +0100
@@ -273,7 +273,6 @@ enum zfcp_wka_status {
 #define ZFCP_STATUS_UNIT_SHARED			0x00000004
 #define ZFCP_STATUS_UNIT_READONLY		0x00000008
 #define ZFCP_STATUS_UNIT_REGISTERED		0x00000010
-#define ZFCP_STATUS_UNIT_SCSI_WORK_PENDING	0x00000020
 
 /* FSF request status (this does not have a common part) */
 #define ZFCP_STATUS_FSFREQ_TASK_MANAGEMENT	0x00000002
@@ -558,6 +557,7 @@ struct zfcp_unit {
 	struct zfcp_erp_action erp_action;     /* pending error recovery */
         atomic_t               erp_counter;
 	struct zfcp_latencies	latencies;
+	struct work_struct	scsi_work;
 };
 
 /* FSF request */
--- a/drivers/s390/scsi/zfcp_erp.c	2009-03-16 16:41:33.000000000 +0100
+++ b/drivers/s390/scsi/zfcp_erp.c	2009-03-16 16:44:04.000000000 +0100
@@ -1184,48 +1184,6 @@ static void zfcp_erp_action_dequeue(stru
 	}
 }
 
-struct zfcp_erp_add_work {
-	struct zfcp_unit  *unit;
-	struct work_struct work;
-};
-
-static void zfcp_erp_scsi_scan(struct work_struct *work)
-{
-	struct zfcp_erp_add_work *p =
-		container_of(work, struct zfcp_erp_add_work, work);
-	struct zfcp_unit *unit = p->unit;
-	struct fc_rport *rport = unit->port->rport;
-
-	if (rport && rport->port_state == FC_PORTSTATE_ONLINE)
-		scsi_scan_target(&rport->dev, 0, rport->scsi_target_id,
-			 scsilun_to_int((struct scsi_lun *)&unit->fcp_lun), 0);
-	atomic_clear_mask(ZFCP_STATUS_UNIT_SCSI_WORK_PENDING, &unit->status);
-	zfcp_unit_put(unit);
-	wake_up(&unit->port->adapter->erp_done_wqh);
-	kfree(p);
-}
-
-static void zfcp_erp_schedule_work(struct zfcp_unit *unit)
-{
-	struct zfcp_erp_add_work *p;
-
-	p = kzalloc(sizeof(*p), GFP_KERNEL);
-	if (!p) {
-		dev_err(&unit->port->adapter->ccw_device->dev,
-			"Registering unit 0x%016Lx on port 0x%016Lx failed\n",
-			(unsigned long long)unit->fcp_lun,
-			(unsigned long long)unit->port->wwpn);
-		return;
-	}
-
-	zfcp_unit_get(unit);
-	atomic_set_mask(ZFCP_STATUS_UNIT_SCSI_WORK_PENDING, &unit->status);
-	INIT_WORK(&p->work, zfcp_erp_scsi_scan);
-	p->unit = unit;
-	if (!queue_work(zfcp_data.work_queue, &p->work))
-		zfcp_unit_put(unit);
-}
-
 static void zfcp_erp_action_cleanup(struct zfcp_erp_action *act, int result)
 {
 	struct zfcp_adapter *adapter = act->adapter;
@@ -1238,9 +1196,10 @@ static void zfcp_erp_action_cleanup(stru
 		if ((result == ZFCP_ERP_SUCCEEDED) && !unit->device) {
 			atomic_set_mask(ZFCP_STATUS_UNIT_REGISTERED,
 					&unit->status);
-			if (!(atomic_read(&unit->status) &
-			      ZFCP_STATUS_UNIT_SCSI_WORK_PENDING))
-				zfcp_erp_schedule_work(unit);
+			zfcp_unit_get(unit);
+			if (scsi_queue_work(unit->port->adapter->scsi_host,
+					    &unit->scsi_work) <= 0)
+				zfcp_unit_put(unit);
 		}
 		zfcp_unit_put(unit);
 		break;
--- a/drivers/s390/scsi/zfcp_scsi.c	2009-03-16 16:41:33.000000000 +0100
+++ b/drivers/s390/scsi/zfcp_scsi.c	2009-03-16 16:42:42.000000000 +0100
@@ -588,6 +588,20 @@ void zfcp_scsi_rport_work(struct work_st
 }
 
 
+void zfcp_scsi_scan(struct work_struct *work)
+{
+	struct zfcp_unit *unit = container_of(work, struct zfcp_unit,
+					      scsi_work);
+	struct fc_rport *rport = unit->port->rport;
+
+	if (rport && rport->port_state == FC_PORTSTATE_ONLINE)
+		scsi_scan_target(&rport->dev, 0, rport->scsi_target_id,
+				 scsilun_to_int((struct scsi_lun *)
+						&unit->fcp_lun), 0);
+
+	zfcp_unit_put(unit);
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
--- a/drivers/s390/scsi/zfcp_ext.h	2009-03-16 16:41:33.000000000 +0100
+++ b/drivers/s390/scsi/zfcp_ext.h	2009-03-16 16:42:42.000000000 +0100
@@ -159,6 +159,7 @@ extern void zfcp_scsi_rport_work(struct 
 extern void zfcp_scsi_schedule_rport_register(struct zfcp_port *);
 extern void zfcp_scsi_schedule_rport_block(struct zfcp_port *);
 extern void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *);
+extern void zfcp_scsi_scan(struct work_struct *);
 
 /* zfcp_sysfs.c */
 extern struct attribute_group zfcp_sysfs_unit_attrs;
