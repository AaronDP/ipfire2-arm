From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: zfcp: unrecoverable port on D_ID change.
References: bnc#499845,LTC#53175 

Symptom:     Remote storage port remains offline.
Problem:     If, for whatever reason, the destination ID of a
             remote storage port changes, it won't become available 
             again. The problem is that in such a situation the
             mapping between the WWPN and D_ID is breaking. Since
             all communication in a SAN is done via the D_ID, the
             zfcp driver is treating this "new" D_ID as an unknown
             reference leading to no further action.
Solution:    Trigger a port reopen in situations which could be
             the result of a changed D_ID and trigger a port reopen
             for all ports having no D_ID on RSCN receiption.

Acked-by: John Jolly <jjolly@suse.de>

---
 drivers/s390/scsi/zfcp_dbf.c |    4 ++--
 drivers/s390/scsi/zfcp_erp.c |   10 ++++++++--
 drivers/s390/scsi/zfcp_fc.c  |    7 ++++++-
 3 files changed, 16 insertions(+), 5 deletions(-)

Index: linux-sles11/drivers/s390/scsi/zfcp_erp.c
===================================================================
--- linux-sles11.orig/drivers/s390/scsi/zfcp_erp.c
+++ linux-sles11/drivers/s390/scsi/zfcp_erp.c
@@ -892,7 +892,6 @@ static int zfcp_erp_port_strategy_open_c
 		return zfcp_erp_port_strategy_open_port(act);
 
 	case ZFCP_ERP_STEP_PORT_OPENING:
-		/* D_ID might have changed during open */
 		if (p_status & ZFCP_STATUS_COMMON_OPEN) {
 			if (p_status & ZFCP_STATUS_PORT_DID_DID)
 				return ZFCP_ERP_SUCCEEDED;
@@ -900,8 +899,15 @@ static int zfcp_erp_port_strategy_open_c
 				act->step = ZFCP_ERP_STEP_PORT_CLOSING;
 				return ZFCP_ERP_CONTINUES;
 			}
-		/* fall through otherwise */
 		}
+		if ((atomic_read(&port->status) & ZFCP_STATUS_PORT_DID_DID) &&
+		    !(p_status & ZFCP_STATUS_COMMON_NOESC)) {
+			atomic_clear_mask(ZFCP_STATUS_PORT_DID_DID,
+					  &port->status);
+			_zfcp_erp_port_reopen(port, 0, 56, NULL);
+			return ZFCP_ERP_EXIT;
+		}
+		/* fall through otherwise */
 	}
 	return ZFCP_ERP_FAILED;
 }
Index: linux-sles11/drivers/s390/scsi/zfcp_dbf.c
===================================================================
--- linux-sles11.orig/drivers/s390/scsi/zfcp_dbf.c
+++ linux-sles11/drivers/s390/scsi/zfcp_dbf.c
@@ -545,8 +545,8 @@ static const char *zfcp_rec_dbf_ids[] = 
 	[53]	= "port boxed fcp",
 	[54]	= "unit boxed fcp",
 	[55]	= "port access denied",
-	[56]	= "",
-	[57]	= "",
+	[56]	= "port d_id changed",
+	[57]	= "port reopen on RSCN reception",
 	[58]	= "",
 	[59]	= "unit access denied",
 	[60]	= "shared unit access denied open unit",
Index: linux-sles11/drivers/s390/scsi/zfcp_fc.c
===================================================================
--- linux-sles11.orig/drivers/s390/scsi/zfcp_fc.c
+++ linux-sles11/drivers/s390/scsi/zfcp_fc.c
@@ -127,9 +127,14 @@ static void _zfcp_fc_incoming_rscn(struc
 	struct zfcp_port *port;
 
 	read_lock_irqsave(&zfcp_data.config_lock, flags);
-	list_for_each_entry(port, &fsf_req->adapter->port_list_head, list)
+	list_for_each_entry(port, &fsf_req->adapter->port_list_head, list) {
 		if ((port->d_id & range) == (elem->nport_did & range))
 			zfcp_test_link(port);
+		if (!(atomic_read(&port->status) & ZFCP_STATUS_PORT_DID_DID))
+			zfcp_erp_port_reopen(port,
+					     ZFCP_STATUS_COMMON_ERP_FAILED, 57,
+					     0);
+	}
 
 	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
 }
