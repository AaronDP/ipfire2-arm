From 32ffe13b1e76244d93fd28087875d5b182472105 Mon Sep 17 00:00:00 2001
From: Steve Ma <steve.ma@intel.com>
Date: Wed, 4 Feb 2009 17:29:20 -0800
Subject: [PATCH] fcoe: exch mgr is freed while lport still retrying sequences
References: bnc#473603

When a sequence cannot be delivered to the target, the local
port will schedule retries, While this process is in progress,
if we destroy the FCoE interface, the fcoe_sw_destroy routine is
entered, and the fc_exch_mgr_free(lp->emp) is called.  Thus
if fc_exch_alloc() is called when retrying the sequence,
the mempool_alloc() will fail to allocate the exchange because
the mempool of the exchange manager has already been released.
This patch is to cancel any pending retry work of the local
port before we start to destroy the interface.

Also, when resetting the local port, we should also stop the
scheduled pending retries.

Signed-off-by: Steve Ma <steve.ma@intel.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/scsi/libfc/fc_lport.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/drivers/scsi/libfc/fc_lport.c b/drivers/scsi/libfc/fc_lport.c
index 74f4a0f..780c571 100644
--- a/drivers/scsi/libfc/fc_lport.c
+++ b/drivers/scsi/libfc/fc_lport.c
@@ -617,6 +617,7 @@ int fc_fabric_logoff(struct fc_lport *lport)
 {
 	lport->tt.disc_stop_final(lport);
 	mutex_lock(&lport->lp_mutex);
+	cancel_delayed_work_sync(&lport->retry_work);
 	fc_lport_enter_logo(lport);
 	mutex_unlock(&lport->lp_mutex);
 	return 0;
@@ -938,6 +939,7 @@ static void fc_lport_enter_reset(struct fc_lport *lport)
 		       fc_host_port_id(lport->host), fc_lport_state(lport));
 
 	fc_lport_state_enter(lport, LPORT_ST_RESET);
+	cancel_delayed_work_sync(&lport->retry_work);
 
 	if (lport->dns_rp)
 		lport->tt.rport_logoff(lport->dns_rp);
-- 
1.5.4.5

