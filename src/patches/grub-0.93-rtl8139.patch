--- rtl8139.c.old	2004-01-25 17:49:38.000000000 +0000
+++ rtl8139.c	2004-01-25 18:20:29.000000000 +0000
@@ -161,19 +161,11 @@
 /* The RTL8139 can only transmit from a contiguous, aligned memory block.  */
 static unsigned char tx_buffer[TX_BUF_SIZE] __attribute__((aligned(4)));
 
-/* I know that this is a MEGA HACK, but the tagged boot image specification
- * states that we can do whatever we want below 0x10000 - so we do!  */
-/* But we still give the user the choice of using an internal buffer
-   just in case - Ken */
-#ifdef	USE_LOWMEM_BUFFER
-#define rx_ring ((unsigned char *)(0x10000 - (RX_BUF_LEN + 16)))
-#else
 static unsigned char rx_ring[RX_BUF_LEN+16] __attribute__((aligned(4)));
-#endif
 
 struct nic *rtl8139_probe(struct nic *nic, unsigned short *probeaddrs,
 	struct pci_device *pci);
-static int read_eeprom(int location);
+static int read_eeprom(int location, int addr_len);
 static void rtl_reset(struct nic *nic);
 static void rtl_transmit(struct nic *nic, const char *destaddr,
 	unsigned int type, unsigned int len, const char *data);
@@ -186,6 +178,8 @@
 {
 	int i;
 	int speed10, fullduplex;
+	int addr_len;
+	unsigned short *ap = (unsigned short*)nic->node_addr;
 
 	/* There are enough "RTL8139" strings on the console already, so
 	 * be brief and concentrate on the interesting pieces of info... */
@@ -199,15 +193,9 @@
 	/* Bring the chip out of low-power mode. */
 	outb(0x00, ioaddr + Config1);
 
-	if (read_eeprom(0) != 0xffff) {
-		unsigned short *ap = (unsigned short*)nic->node_addr;
-		for (i = 0; i < 3; i++)
-			*ap++ = read_eeprom(i + 7);
-	} else {
-		unsigned char *ap = (unsigned char*)nic->node_addr;
-		for (i = 0; i < ETH_ALEN; i++)
-			*ap++ = inb(ioaddr + MAC0 + i);
-	}
+	addr_len = read_eeprom(0,8) == 0x8129 ? 8 : 6;
+	for (i = 0; i < 3; i++)
+	  *ap++ = read_eeprom(i + 7,addr_len);
 
 	speed10 = inb(ioaddr + MediaStatus) & MSRSpeed10;
 	fullduplex = inw(ioaddr + MII_BMCR) & BMCRDuplex;
@@ -217,6 +205,10 @@
 
 	rtl_reset(nic);
 
+	if (inb(ioaddr + MediaStatus) & MSRLinkFail) {
+		printf("Cable not connected or other link failure\n");
+		return(0);
+	}
 	nic->reset = rtl_reset;
 	nic->poll = rtl_poll;
 	nic->transmit = rtl_transmit;
@@ -244,22 +236,23 @@
 #define eeprom_delay()  inl(ee_addr)
 
 /* The EEPROM commands include the alway-set leading bit. */
-#define EE_WRITE_CMD    (5 << 6)
-#define EE_READ_CMD     (6 << 6)
-#define EE_ERASE_CMD    (7 << 6)
+#define EE_WRITE_CMD    (5)
+#define EE_READ_CMD     (6)
+#define EE_ERASE_CMD    (7)
 
-static int read_eeprom(int location)
+static int read_eeprom(int location, int addr_len)
 {
 	int i;
 	unsigned int retval = 0;
 	long ee_addr = ioaddr + Cfg9346;
-	int read_cmd = location | EE_READ_CMD;
+	int read_cmd = location | (EE_READ_CMD << addr_len);
 
 	outb(EE_ENB & ~EE_CS, ee_addr);
 	outb(EE_ENB, ee_addr);
+	eeprom_delay();
 
 	/* Shift the read command bits out. */
-	for (i = 10; i >= 0; i--) {
+	for (i = 4 + addr_len; i >= 0; i--) {
 		int dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;
 		outb(EE_ENB | dataval, ee_addr);
 		eeprom_delay();
@@ -279,9 +272,28 @@
 
 	/* Terminate the EEPROM access. */
 	outb(~EE_CS, ee_addr);
+	eeprom_delay();
 	return retval;
 }
 
+static const unsigned int rtl8139_rx_config = 
+	(RX_BUF_LEN_IDX << 11) |
+	(RX_FIFO_THRESH << 13) |
+	(RX_DMA_BURST << 8);
+	
+static void set_rx_mode(struct nic *nic) {
+	unsigned int mc_filter[2];
+	int rx_mode;
+	/* !IFF_PROMISC */
+	rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+	mc_filter[1] = mc_filter[0] = 0xffffffff;
+
+	outl(rtl8139_rx_config | rx_mode, ioaddr + RxConfig);
+
+	outl(mc_filter[0], ioaddr + MAR0 + 0);
+	outl(mc_filter[1], ioaddr + MAR0 + 4);
+}
+	
 static void rtl_reset(struct nic* nic)
 {
 	int i;
@@ -316,17 +328,24 @@
 #ifdef	DEBUG_RX
 	printf("rx ring address is %X\n",(unsigned long)rx_ring);
 #endif
-	outl((unsigned long)rx_ring, ioaddr + RxBuf);
+	outl((unsigned long)rx_ring, ioaddr + RxBuf);
+
+
 
-	/* Start the chip's Tx and Rx process. */
-	outl(0, ioaddr + RxMissed);
-	/* set_rx_mode */
-	outb(AcceptBroadcast|AcceptMyPhys, ioaddr + RxConfig);
 	/* If we add multicast support, the MAR0 register would have to be
 	 * initialized to 0xffffffffffffffff (two 32 bit accesses).  Etherboot
 	 * only needs broadcast (for ARP/RARP/BOOTP/DHCP) and unicast.  */
+
 	outb(CmdRxEnb | CmdTxEnb, ioaddr + ChipCmd);
+	
+	outl(rtl8139_rx_config, ioaddr + RxConfig);
+	
+	/* Start the chip's Tx and Rx process. */
+	outl(0, ioaddr + RxMissed);
 
+	/* set_rx_mode */
+	set_rx_mode(nic);
+	
 	/* Disable all known interrupts by setting the interrupt mask. */
 	outw(0, ioaddr + IntrMask);
 }
@@ -337,10 +356,11 @@
 	unsigned int status, to, nstype;
 	unsigned long txstatus;
 
+	/* nstype assignment moved up here to avoid gcc 3.0.3 compiler bug */
+	nstype = htons(type);
 	memcpy(tx_buffer, destaddr, ETH_ALEN);
 	memcpy(tx_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN);
-	nstype = htons(type);
-	memcpy(tx_buffer + 2 * ETH_ALEN, (char*)&nstype, 2);
+	memcpy(tx_buffer + 2 * ETH_ALEN, &nstype, 2);
 	memcpy(tx_buffer + ETH_HLEN, data, len);
 
 	len += ETH_HLEN;
@@ -354,7 +374,7 @@
 		tx_buffer[len++] = '\0';
 	}
 
-	outl((unsigned long)tx_buffer, ioaddr + TxAddr0 + cur_tx*4);
+	outl((unsigned long)tx_buffer, ioaddr + TxAddr0 + cur_tx*4);
 	outl(((TX_FIFO_THRESH<<11) & 0x003f0000) | len,
 		ioaddr + TxStatus0 + cur_tx*4);
 
@@ -448,6 +468,8 @@
 
 static void rtl_disable(struct nic *nic)
 {
+	rtl_reset(nic);
+
 	/* reset the chip */
 	outb(CmdReset, ioaddr + ChipCmd);
 
